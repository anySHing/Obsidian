# 명령어의 구조

> `연산 코드`, `오퍼랜드`, `주소 지정 방식` 등장

## 연산 코드와 오퍼랜드

인간이 명령하는 방식

`야, 돈내놔`

컴퓨터의 명령도 마찬가지로 무엇을 대상으로 어떤 작동을 수행하라는 구조로 되어있음

~~`내놔라 돈을`~~

`더해라 100과 120을`

`빼라 메모리 32번지의 값과 메모리 36번지의 값을`

`저장해라 10을 메모리 16번지에`

명령어가 수행할 연산(더해라, 빼라, 저장해라)를 `연산 코드(==연산자)`라 한다.

연산에 사용할 데이터 또는 저장된 주소를 `오퍼랜드(==피연산자)`라 한다.

연산 코드가 담기는 영역은 `연산 코드 필드`,<br>
오퍼랜드가 담기는 영역을 `오퍼랜드 필드`라 부름

### 오퍼랜드

오퍼랜드 필드에는 숫자나 문자와 같이 연산에 사용할 데이터를 직접 명시하기 보다는 주소나 레지스터 이름을 담는 경우가 많다

-> 주소를 담으면 더 큰 값을 담을 수 있으니까 BUT 참조를 여러 번 하게 되기 때문에 성능은 저하될 것

오퍼랜드는 명령어 안에 하나도 없을 수도 있고 한 개 이상이 들어갈 수도 있음

없으면 `0-주소 명령어`<br>
1개면 `1-주소 명령어`<br>
~ 3개면 `3-주소 명령어`

그럼 4개는?

### 연산 코드

기본적인 연산 코드의 유형은 크게 네 가지

- 1. 데이터 전송
  - MOVE: 데이터를 옮겨라
  - STORE: 메모리에 저장하라
  - LOAD(FETCH): 메모리에서 CPU로 데이터를 가져와라
  - PUSH: 스택에 데이터를 저장하라
  - POP: 스택의 최상단 데이터를 가져와라
- 2. 산술/논리 연산
  - ADD / SUBTRACT / MULTIPLY / DIVIDE: 덧셈, 뺄셈, 곱셈, 나눗셈을 수행하라
  - INCREMENT / DECREMENT: 오퍼랜드에 1을 더하라 / 오퍼랜드에 1을 빼라
  - AND / OR / NOT: AND / OR / NOT 연산을 수행하라
  - COMPARE: 두 개의 숫자 또는 TRUE / FALSE 값을 비교하라
- 3. 제어 흐름 변경
  - JUMP: 특정 주소로 실행 순서를 옮겨라
  - CONDITIONAL JUMP: 조건에 부합할 때 특정 주소로 실행 순서를 옮겨라
  - HALT: 프로그램의 실행을 멈춰라
  - **`CALL`**: 되돌아올 주소를 저장한 채 특정 주소로 실행 순서를 옮겨라
  - RETURN: CALL을 호출할 때 저장했던 주소로 돌아가라
    <br>
    -> CALL과 RETURN은 프로그래밍 언어에서 함수를 호출하고 리턴하는 명령어와 비슷함
- 4. 입출력 제어
  - READ(INPUT): 특정 입출력 장치로부터 데이터를 읽어라
  - WRITE(OUTPUT): 특정 입출력 장치로 데이터를 써라
  - START IO: 입출력 장치를 시작하라
  - TEST IO: 입출력 장치의 상태를 확인하라

## 주소 지정 방식

이전에 오퍼랜드 필드에 데이터 대신 메모리나 레지스터의 주소를 담는 경우가 많아 주소 필드라 부르기도 한다고 했음 (오퍼랜드 필드 == 주소 필드)

너무 기니까 주소 필드로 통일해서 불러야겠다

주소 필드에 데이터가 저장된 위치를 명시할 때 연산에 사용할 데이터 위치를 찾는 방법을 `주소 지정 방식`이라고 한다.

-> 유효 주소를 찾는 방법이다

<br><br>

<h1>왜?</h1>

-> 명령어 길이 때문. 하나의 명령어가 n비트로 구성되어 있고, 그 중 연산 코드 필드가 m비트라고 가정한다면,

주소 필드에 가장 많은 공간을 할당할 수 있는 1-주소 명령어라 할지라도 주소 필드의 길이는 연산 코드만큼의 길이를 뺀 `n-m비트`가 된다.

2-주-명 3-주-명 이면 더 작아지게 될 것

---

<br>

연산 코드에 사용할 데이터가 저장된 위치, 즉 연산의 대상이 되는 데이터가 저자된 위치를 `유효 주소`라고 한다.

### 주소 지정 방식 대표적인 다섯 가지

<h3>즉시 주소 지정 방식</h3>

연산에 사용할 데이터를 오퍼랜드 필드에 직접 명시하는 방식

가장 간단한 형태의 주소 지정 방식이며

장점: 빠르다 연산에 사용될 데이터를 메모리나 레지스터에서 찾아오는 과정이 없으니까

단점: 표현할 수 있는 데이터의 크기가 작아짐

<h3>직접 주소 지정 방식</h3>

주소 필드에 유효 주소를 직접적으로 명시하는 방식

즉시 주소 지정 방식보다 표현할 수 있는 데이터의 크기가 커졌지만 여전히 유효 주소를 표할 수 있는 범위가 연산 코드의 비트 수 만큼 줄어들었음

<h3>간접 주소 지정 방식</h3>

주소 필드에 유효 주소의 주소를 명시한다

-> 두 번의 메모리 접근

뭔,,, 주소의주소의...주소의주소의...주소의주소를 명시하면 명령어 하나로 천지창조도 하겠음

연산에 사용될 데이터가 레지스터에 저장된 경우엔 아래에 있는 방식들을 사용한다.

<h3>레지스터 주소 지정 방식</h3>

직접 주소 지정 방식과 비슷하게 연산에 사용할 데이터를 저장한 레지스터를 주소 필드에 명시하는 방식

장점: 메모리까지 갈 필요도 없이 CPU 내부의 레지스터에서 땡겨오기 때문에 아주아주 빠름

단점: 직접 주소 지정 방식과 비슷하게 표현할 수 있는 크기에 제한이 생김

<h3>레지스터 간접 주소 지정 방식</h3>

연산에 사용할 데이터를 메모리에 저장하고, 그 주소(유효 주소)를 저장한 레지스터를 주소 필드에 명시하는 방식

간접 주소 지정 방식과 비슷하지만 메모리에 접근하는 횟수가 한번이기 때문에 더 빠르다

간주지방은 (->메모리->메모리)

레간주지방은 (->레지스터->메모리)

이니까..................................
