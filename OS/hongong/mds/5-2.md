# 명령어 병렬 처리 기법

명령어를 동시에 처리하여 CPU를 한시도 쉬지 않고 작동 시키는 기법인 `명령어 병렬 처리 기법(ILP: Instruction-Level Parallelism)`을 알아본다.

<br><hr>

## 명령어 파이프라이닝

명령어 파이프라인을 이해하려면 하나의 명령어가 처리되는 전체 과정을 비슷한 시간 간격으로 나누어 보아야 한다.

명령어 처리 과정을 클럭 단위로 나누어 보면 이와 같음

1. 명령어 인출(Instruction Fetch)
2. 명령어 해석(Instruction ecode)
3. 명령어 실행(Execute Instruction)
4. 결과 저장(Write Back)

> 꼭 이 단계가 정답은 아니고 <br> `명령어 인출 -> 실행` 으로 나누기로 하고, `명령어 인출 -> 해석 -> 실행 -> 메모리 접근 -> 결과 저장`으로 나누기도 함

<br>

**여기서 중요한 점**: 같은 단계가 겹치지 않는다면 CPU는 **각 단계를 동시에 실행할 수 있다.**<br>

ex) 한 명령어를 `1. 인출` 하는 동안에 `다른 명령어를 실행`할 수 있고, `한 명령어가 실행`되는 동안 `연산 결과를 저장`할 수 있음 (157p 사진 참고)

이을 마치 공장 생산 라인과 같이 명령어들을 `명령어 파이프라인`에 넣고 동시에 처리한다고 하여 `명령어 파이프라이닝`이라고 부름

파이프라이닝이 특정 상황에서는 성능 향상에 실패하는 경우가 있는데, `파이프 라인 위험(pipeline hazard)`라고 부른다.

크게 `데이터 위험`, `제어 위험`, `구조 위험`등이 있다.

### 데이터 위험

명령어 간 `데이터 의존성`에 의해 발생한다.<br>

어떤 명령어는 이전 명령어를 끝까지 실행해야만 실행할 수 있는 경우가 있다 <- 이를 의존성을 갖는다고 함

```
명령어 1: R1 <- R2 + R3 // R2 레지스터 값과 R3 레지스터 값을 더한 값을 R1 레지스터에 저장
명령어 2: R4 <- R1 + R5 // R1 레지스터 값과 R5 레지스터 값을 더한 값을 R4 레지스터에 저장
```

이러한 경우에 명령어 1을 수행해야만 명령어 2를 수행할 수 있기 때문에 파이프 라인이 제대로 작동하지 않음

<br>

### 제어 위험

주로 분기 등으로 인한 `프로그램 카운터의 갑작스러운 변화`에 의해 발생

기본적으로 프로그램 카운터는 `현재 실행 중인 명령어의 다음 주소`로 갱신되는데,

프로그램의 실행 흐름이 바뀌어 명령어가 실행되면서 프로그램 카운터 값에 갑작스러운 변화가 생긴다면

명령어 파이프라인에 미리 가지고 와서 처리 중이었던 명령어들은 아무 쓸모가 없어진다. <- `제어 위험`이라고 함

-> 이를 위해 `분기 예측`이라는 기술이 있음

<br>

### 구조적 위험

명령어들을 겹쳐 실행하는 과정에서 서로 다른 명령어가 동시에 ALU, 레지스터 등과 같은 CPU 부품을 사용하려고 할 때 발생함

**자료 위험** 이라고도 부른다.

<br><hr>

## 슈퍼스칼라

오늘날 대부분의 CPU에서는 여러 개의 파이프라인을 이용하는데, 이처럼 CPU 내부에 여러 개의 명령어 파이프 라인을 포함한 구조를 **슈퍼스칼라** 라고 함

슈퍼스칼라 구조로 명령어 처리가 가능한 CPU를 `슈퍼스칼라 프로세서` 혹은 `슈퍼스칼라 CPU`라고 부름

슈퍼스칼라 프로세서는 매 클럭 주기마다 동시에 여러 명령어를 인출할 수도, 실행할 수도 있어야 한다.

가령 멀티스레드 프로세서는 한 번에 여러 명령어를 인출하고, 해석하고, 실행할 수 있기 때문에 슈퍼스칼라 구조를 사용할 수 있다.

<br><hr>

## 비순차적 명령어 처리

보통 `OoOE`로 줄여 부른다. 오늘날 CPU 성능 향상에 크게 기여한 기법이자 대부분의 CPU가 차용하는 기법이기 때문에 알아두는 것이 좋음

이름에서도 알 수 있듯 명령어ㄹ들을 순차적으로 실행하지 않는 기법이다. 명령어의 합법적 새치기

<br>

지금까지 설명했던 파이프라이닝, 슈퍼스칼라는 모두 여러 명령어의 순차적인 처리를 산정한 방법이었다.

아래와 같은 명령어들이 있다고 가정한다. 편의상 '메모리 N번지' 는 **M(N)**, 

'메모리 N번지에 M을 저장하라'는 **M(N) <- M** 으로 표기한다

```
1. M(100) <- 1
2. M(101) <- 2
3. M(102) <- M(100) + M(101)
4. M(150) <- 1
5. M(151) <- 2
6. M(152) <- 3
```

<br>

여기에서 주목해야 할 점은 3번 명령어를 실행하기 위해서는 M(100), M(101) 값이 결정되어야 하기에 1번, 2번 명령어가 실행이 끝날 떄 까지 기다려야 한다는 것이다.

그럼 여기서 순서를 바꿔서 1, 2, 4, 5, 6, 3의 순서로 명령어를 실행해도 크게 문제될 것이 없다.

이런 식으로 순서를 바꿔 실행해도 무방한 명령어를 먼저 실행하여 명령어 파이프 라인이 멈추는 것을 방지하는 기법을 *비순차적 명령어 처리 기법** 이라고 한다.