<h1>명령어 사이클과 인터럽트</h1>

CPU가 하나의 명령어를 처리하는 과정에는 정해진 흐름이 있고, 그 흐름을 반복하며 명령어를 처리해나간다.

이렇게 하나의 명령어를 처리하는 정형화된 흐름 == **명령어 사이클**

<hr>

CPU는 정해진 흐름에 따라 명령어를 처리해 나가지만, 간혹 흐름이 끊어지는 상황이 발생하는데 <- **인터럽트**

<br><hr>

## 명령어 사이클

프로그램 속 각각의 명령어들이 실행되는 일정한 주기

인출 사이클, 실행 사이클, 간접 사이클이 있음 (사이사이에 인터럽트 낌)

<br><hr>

### 인출 사이클

명령어 사이클의 첫 번째 단계, 일단 명령어를 메모리에서 CPU로 가져와야 뭘 하든가 하지

[4-2](./4-2.md)의 2 ~ 6단계 (책 115p)가 인출 사이클의 과정

<hr>

### 실행 사이클

CPU로 명령어를 인출했다면 이제 명령어를 실행해야지 == 실행 사이클

제어장치가 명령어 레지스터에 담긴 값을 해석하고, 제어 신호를 발생시키는 단계

<hr>

### 간접 사이클

일반적으로 인출, 실행, 인출, 실행 반복인데 문제가 있을 수 있다

무엇이냐 하면 간접 주소 지정 방식으로 지정된 주소를 가져왔을 땐 메모리 접근을 한번 더 해서 또 가져와야 한다. == 간접 사이클

<hr>

## 인터럽트

끝이 아니다 또 있다 인터럽트가 방해할 수 있다

동기, 비동기 인터럽트로 나뉜다

### 동기 인터럽트

CPU에 의해 발생하는 인터럽트. CPU가 명령어들을 수행하다가 예상치 못한 상황에 마주쳤을 때 발생함, 오류같은거

`Exception`이라고 들어본 그놈들

<br><hr>

### 비동기 인터럽트

입출력 장치에 의해 발생하는 인터럽트. 알림 역할을 함

ex) CPU가 프린터에 입출력 작업을 시키면 프린터가 다 됐다고 CPU한테 알림 보냄<br>
ex) 키보드나 마우스가 어떠한 입력을 받아들였을 때 이를 처리하기 위해 CPU에 입력 알림 보냄...

일반적으로 비동기 인터럽트를 보고 인터럽트라 칭함

비동기 인터럽트 == (통상적)인터럽트 == 하드웨어 인터럽트

<br><hr>

### 하드웨어 인터럽트

아까 말했듯 알림이랬음

CPU는 입출력 작업 도중에도 효율적으로 명령어를 처리하기 위해 이런 알림과 같은 하드웨어 인터럽트를 사용함.

<h2>효율이랑 인터럽트랑 뭔상관인데</h2>

CPU가 프린터에 출력을 명령했을 경우 입출력 장치는 CPU보다 속도가 아주 느리기 때문에 CPU는 속터져죽음.......... 

하드웨어 인터럽트 쓰지 않을경우 주기적으로 일 다 마쳤는지 확인해야됨 <- 확인하러 왔다갔다하는 자체가 개낭비

인터럽트 쓰면 지할일하다가 알림오면 가서 처리하면됨 굿

<h3>하드웨어 인터럽트 처리 순서</h3>

1. I/O 장치가 CPU에 **인터럽트 요청 신호**를 보냄
2. CPU는 실행 사이클이 끝나고 명령어를 인출하기 전에 항상 인터럽트 여부를 확인함
3. 인터럽트 요청을 확인하고 **인터럽트 플래그**를 통해 현재 인터럽트를 받아들일 수 있는지 여부 확인
4. 인터럽트를 받아들일 수 있다면 지금까지의 작업을 백업해둠
5. **인터럽트 벡터**를 참조하여 **인터럽스 서비스 루틴**을 실행
6. 끝나면 (4)에서 백업해둔 작업 복구하여 다시 작업 시작

<hr>

<h2>앗 처음보는 용어가 나왔다</h2>

- 인터럽트 요청 신호: 입출력 신호가 CPU에게 지금 끼어들어도 되나요? 하고 묻는 것
- 인터럽트 플래그: CPU가 인터럽트 요청을 수용하려면 `플래그 레지스터`에 인터럽트 플래그가 활성화 되어있어야 함. CPU가 중요한 작업을 처리 중이거나 방해받지 말아야 할 경우에는 플래그가 불가능으로 설정됨

근데 다 막을 수는 없음 ;; (정전이나 하드웨어 고장으로 인한 인터럽트는 못막음)

여기서 비동기 인터럽트(== 하드웨어 인터럽트)가 막을 수 있는(maskable) 인터럽트 / 막을 수 없는(non-maskable) 인터럽트 로 나뉘어짐

- 인터럽트 서비스 루틴: CPU가 인터럽트 요청을 받아들이기로 했다면 CPU는 인터럽트 서비스 루틴이라는 프로그램을 실행함. **인터럽트 핸들러** 라고도 부름

-> 키보드가 어떤 인터럽트 요청을 보냈을 때 어떻게 작동한다 / 마우스가 어떤 인터럽트 요청을 보냈을 때 어떻게 작동한다. 프로그램에 어떤 문제가 생겼을 때 어떻게 작동한다 같은 정보로 이루어져 있음

- 인터럽트 벡터: 각기 다른 인터럽트 서비스 루틴을 구분하기 위한 정보, 인터럽트 벡터를 알면 인터럽트 서비스 루틴의 시작 주소를 알 수 있음

**\* CPU는 하드웨어 인터럽트 요청을 보낸 대상으로부터 데이터 버스를 통해 인터럽트 벡터를 전달받는다.**

<hr>

<h2>예외의 종류</h2>

예외가 발생하면 CPU는 하던 일을 중단하고 예외를 처리함. 처리하고 나면 본래 하던 작업으로 되돌아와 실행을 재개.

이 때 `예외가 발생한 명령어부터` 실행하면 `폴트(fault)`, `예외가 발생한 명령어 다음 명령어부터` 실행하면 `트랩(trap)`이라고 부름.

`중단(abort)`은 CPU가 실행 중인 프로그램을 강제로 중단시킬 수 밖에 없는 심각한 오류를 발견했을 때 발생하는 예외

