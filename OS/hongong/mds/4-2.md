# 레지스터

> 레지스터의 종류와 역할을 학습하고, 각 레지스터를 통해 명령어가 처리되는 과정을 이해

프로그램 속 명령어와 데이터는 실행 전후로 반드시 레지스터에 저장된다. 따라서 레지스터에 저장된 값만 잘 관찰해도 프로그램의 실행 흐름을 파학할 수 있음

다시 말해 레지스터 속 값을 유심히 관찰하면 프로그램을 실행할 때 CPU 내에서 무슨 ㅇ리이 벌어지고 있는지, 어떤 명령어가 어떻게 수행되는지 알 수 있음

## 반드시 알아야 할 레지스터

상용화된 CPU속 레지스터들은 CPU마다 이름, 크기, 종류가 매우 다양한데 여기서는 공통되는 8개의 레지스터만 알아보고

나머지는 알아서 인텔 AMD 홈페이지 찾아가서 알아보셈

1. 프로그램 카운터(== 명령어 포인터(Instruction Pointer))

- 메모리에서 가져올 명령어의 주소, 즉 메모리에서 읽어들일 명령어의 주소를 저장

2. 명령어 레지스터

- 해석할 명령어, 즉 방금 메모리에서 읽어들인 명령어를 저장하는 레지스터. 제어 장치는 명령어 레지스터 속 명령어를 받아들이고 이를 해석한 뒤 제어 신호를 내보낸다.

3. 메모리 주소 레지스터

- 메모리의 주소를 저장하는 레지스터, CPU가 읽어들이고자 하는 주소 값을 주소 버스로 보낼 때 메모리 주소 레지스터를 거치게 된다.

4. 메모리 버퍼 레지스터(== 메모리 데이터 레지스터(MDR; Memory data Register)

- 메모리와 주고받을 값(데이터와 명령어)을 저장하는 레지스터. 즉, 메모리에 쓰고 싶은 값이나 메모리로부터 전달받은 값은 메모리 버퍼 레지스터를 거친다. CPU가 주소 버스로 내보낼 값이 메모리 주소 레지스터를 거친다면, 데이터 버스로 주고바을 값은 메모리 버퍼 레지스터를 거친다.

---

메모리에 저장된 프로그램을 실행하는 고자어에서 프로그램 카운터, 명령어 레지스터, 메모리 주소 레지스터, 메모리 버퍼 레지스터에 어떤 값이 담기는 지 알아보자

- CPU로 실행할 프로그램이 1000번지부터 100번지까지 저장되어 있고 1000번지에는 1101(2)이 저장되어 있다고 가정

1. 프로그램을 처음부터 실행하기 위해 `프로그램 카운터`에 1000이 저장됨. (메모리에서 가져올 명령어가 1000번지에 있다는 걸 의미)

2. 1000번지를 읽어 들이기 위해서는 주소 버스로 1000번지를 내보내야 한다. 이를 위해 `메모리 주소 레지스터`에 1000이 저장됨.

3. '메모리 읽기' 제어 신호와 메모리 주소 레지스터 값이 각각 제어 버스와 주소 버스를 통해 메모리로 보내짐

4. 메모리 1000번지에 저장된 값은 데이터 버스를 통해 `메모리 버퍼 레지스터`로 전달되고, `프로그램 카운터`는 증가되어 다음 명령어를 읽어들일 준비를 한다.

5. 메모리 버퍼 레지스터에 저장된 값을 명령어 레지스터로 이동

6. 제어 장치는 명령어 레지스터의 명령어를 해석하고 제어 신호를 발생시킨다.

4단계에서 프로그램 카운터 값이 증가한 것을 확인했다. 프로그램 카운터 값이 증가했으니 1000번지 명령어 처리가 끝나면 CPU는 다음 명령어 (1001번지)를 읽어들인다.

이처럼 프로그램 카운터는 지속적으로 증가하며 계속해서 다음 명령어를 읽어들일 준비를 한다.

이 과정이 반복되면서 CPU는 프로그램을 차례대로 실행해나간다. 결국 CPU가 메모리 속 프로그램을 순차적으로 읽어들이고 실행해 나갈 수 있는 이유는 CPU 속 프로그램 카운터가 꾸준히 증가하기 때문

- 순차적인 실행 흐름이 끊기는 경우

일반적으로 프로그램 카운터는 꾸준히 증가하며 프로그램을 차례대로 실행한다. 하짐나 종종 프로그램 카운터가실행중인 명령어의 다음 번지 주소가 아닌 전혀 다른 값으로 업데이트 되는 경우가 있다. 이런 상황이라면 프로그램이 차례대로 실행되지 않는다. 이런 상황은 언제 발생할까?

명령어 중 JUMP, CONDITIONAL JUMP, CALL, RET과 같이 특정 메모리 주소로 실행 흐름을 이동하는 명령어가 실행되었을 때 프로그램은 차례대로 실행되지 않는다. 이런 경우 프로그램 카운터에는 변경된 주소가 저장된다

가령 1200번지를 실행하는 도중 JUMP 2500이라는 명령어를 만났다면 다음에는 1202 번지가 아닌 2500 번지를 실행해야 하기 때문에 프로그램 카운터에는 1201 번지가 아닌 2500 번지가 저장된다.

또한 인터럽트가 발생해도 프로그램의 순차적인 실행 흐름이 끊어진다.

---

5. 플래그 레지스터

- 연산 결과 또는 CPU 상태에 대한 부가적인 정보를 저장하는 레지스터

6. 범용 레지스터

- 이름 그대로 다양하고 일반적인 상황에서 자유롭게 사용할 수 있는 레지스터 <br> 메모리 버퍼 레지스터는 데이터 버스로 주고 받을 값만 저장하고, 메모리 주소 레지스터는 주소 버스로 내보낼 주소 값만 저장하지만, 범용 레지스터는 데이터와 주소를 모두 저장할 수 있다.<br> 일반적으로 CPU 안에는 여러 개의 범용 레지스터들이 있고, 현대 대다수 CPU는 모두 범용 레지스터를 가지고 있다.

### 특정 레지스터를 이용한 주소 지정 방식(1): 스택 주소 지정 방식

7. 스택 포인터

스택 주소 지정 방식에 사용되는 레지스터

- `스택 주소 지정 방식`?

스택과 스택 포인터를 이용한 주소 지정 방식이다.

**스택**은 한 쪽 끝이 막혀있는 통과 같은 저장 공간이다. LIFO 구조를 가지고 있다. 이놈은 어디에 있냐? 메모리에 있다. 메모리에 스택 처럼 활용할 **스택 영역**을 따로 만들어뒀다.

**스택 포인터**란 스택의 꼭대기를 가리키는 레지스터이다. 즉 스택에 마지막으로 저장한 값의 위치를 저장하는 레지스터이다.

사진 참고) 119p

### 특정 레지스터를 이용한 주소 지정 방식(2): 변위 주소 지정 방식

**변위 주소 지정 방식**이란 오퍼랜드 필드의 값(변위)과 특정 레지스터의 값을 더하여 유효 주소를 얻어내는 주소 지정 방식

`변위 주소 지정 방식`을 사용하는 명령어는 `연산 코드 필드`, `레지스터 필드`, `오퍼랜드 필드`가 있음

사진 참고) 120p

오퍼랜드 필드의 주소와 어떤 레지스터를 더하는지에 따라 **상대 주소 지정 방식**, **베이스 레지스터 주소 지정 방식**등으로 나뉜다.

#### 상대 주소 지정 방식

오퍼랜드와 프로그램 카운터의 값을 더하여 유효 주소를 얻는 방식

프로그램 카운터에는 읽어들일 명령어의 주소가 저장되어 있다.

만약 오퍼랜드가 음수, 예를 들어 -3이었다면 CPU는 읽어들이기로 한 명령어로부터 '세 번쨰 이전' 번지로 접근함.

-> 실행하려는 명령어의 세 칸 이전 번지 명령어를 실행함

`상대 주소 지정 방식`은 프로그래밍 언어의 if문과 유사하게

모든 코드를 실행하는 것이 아닌, 분기하여 특정 주소의 코드를 실행할 떄 사용한다.

#### 베이스 레지스터 주소 지정 방식

오퍼랜드와 베이스 레지스터의 값을 더하여 유효 주소를 얻는 방식

여기서 `베이스 레지스터`는 '기준 주소', 오퍼랜드는 '기준 주소로부터 떨어진 거리'로서의 역할을 한다.

-> 베이스 레지스터 속 기준 주소로부터 얼마나 떨어져 있는 주소에 접근할 것인지를 연산하여 유효 주소를 얻어내는 방식

<br>

ex) 베이스 레지스터에 200이라는 값이 있고 오퍼랜드가 40이라면 '기준 주소 200번지로부터 40만큼 떨어진 240번지로 접근하라'를 의미

<br><hr>
# 요약

- **프로그램 카운터**: 메모리에서 가져올 명령어의 주소 저장
- **명령어 레지스터**: 해석할 명령어 저장
- **메모리 레지스터**: 메모리의 주소 저장
- **메모리 버퍼 레지스터**: 메모리와 주고받을 데이터 저장
- **범용 레지스터**: 데이터와 주소 모두 저장
- **플래그 레지스터**: 연산 결과 혹은 CPU 상태에 대한 부가 정보 저장
- **스택 포인터**: 스택 최상단의 위치 저장
- **베이스 레지스터**에 저장된 주소 == 기준 주소