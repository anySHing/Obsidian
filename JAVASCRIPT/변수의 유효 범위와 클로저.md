함수가 생성된 이후에 외부 변수가 변경되면 어떤 일이 발생하는지,

매개 변수를 통해 함수를 넘기고 이 함수를 저 멀리 떨어진 코드에서 호출할 땐 어떤 일이 발생하는지,

함수는 호출되는 곳을 기준으로 외부 변수에 접근하는지, 이런것들 알아본다.

> 여기선 `let`, `const`로 선언된 변수만 다룸
> `var`는 [오래된 var](./)에서 다룬다.

## 코드 블록

코드 블록 `{...}` 안에서 선언한 변수는 블록 안에서만 사용할 수 있다.

```js
{
	// 지역 변수를 선언하고 몇 가지 조작을 해봤짐나 그 결과를 밖에서 볼 수 없다.

	let message = '안녕하세요.'; // 블록 내에서만 변수 값을 얻을 수 있다.

	alert(message); // OK
}
alert(message); // ReferenceError: message is not defined
```

이런 블록의 특징은 특정 작업을 수행하는 코드를 한데 묶어두는 용도로 사용할 수 있다. 블록 안엔 작업 수행에만 필요한 변수가 들어간다.

```js
{
	// 메시지 출력
	let message = '안녕하세요.';
	alert(message); // OK
}

{
  // 또 다른 메시지 출력
  let message = '안녕히 가세요.';
  alert(message); // OK
}
```

<br>

`if`, `for`, `while` 등에서도 마찬가지로 `{...}` 안에서 선언한 변수는 오직 블록 안에서만 접근 가능하다.

```js
if(true) {
  let phrase = '안녕하세요.';
  alert(phrase);
}
alert(phrase); // ReferenceError: phrase is not defined
```

`if` 블록 밖에 있는 `alert`는 `phrase`에 접근할 수 없기 때문에 에러가 발생한다.

이러한 특징은 변수의 유효 범위를 블록 범위, 특히 `if` 분기문 범위로 한정할 수 있어서 아주 유용하다. 

`if` 뿐만 아니라 `for`, `while`에서도 동일한 특징이 적용된다

<br>

## 중첩 함수

함수 내부에서 선언한 함수는 '중첩(nested) 함수'라고 부른다.

중첩 함수는 아래와 같이 코드를 정돈하는데 사용할 수 있다.

```js
function sayHiBye(firstName, lastName) {
  // 헬퍼(helper) 중첩 함수
  function getFullName() {
    return firstName + ' ' + lastName;
  }

  alert(`Hello, ${getFullName()}`);
  alert(`Bye, ${getFullName()}`);
}
```

중첩 함수는 새로운 객체의 프로퍼티 형태나 중첩 함수 그 자체로 반환될 수 있다는 점에서 흥미롭다. 이렇게 반환된 중첩 함ㅅ는 어디서든 호출해 사용할 수 있다. 물론 이 때도 외부 변수에 접근할 수 있다는 사실은 변함없음.

아래 함수 `makeCounter()`는 호출될 때 마다 다음 숫자를 반환해주는 '카운터' 함수를 만든다.

```js
function makeCounter() {
  let count = 0;
  
  return function() {
    return count++;
  }
}

let counter = makeCounter();

alert(counter()); // 0
alert(counter()); // 1
alert(counter()); // 2
```

`makeCounter()`를 살펴보다 보면 `counter`를 여러 개 만들었을 때, 이 함수들은 서로 독립적일까? 함수와 중첩 함수 내 `count` 변수엔 어떤 값이 할당될까? 하는 의문이 들기 마련이다.

<br>

## 렉시컬 환경

<h3>1. 변수</h3>

자바스크립트에서는 실행중인 함수, 코드 블록`{...}`, 스크립트 전체는 

*렉시컬 환경(Lexical Environment)*이라 불리는 내부 숨김 연관 객체(internal hidden associated object)를 갖는다.

렉시컬 환경 객체는 두 부분으로 구성된다.

1. *환경 레코드(Environment Record)*: 모든 지역 변수를 프로퍼티로 저장하고 있는 객체이다. `this`와 같은 기타 정보도 여기에 저장된다.
2. *외부 렉시컬 환경(Outer Lexical Environment)에 대한 참조*: 외부 코드와 연관됨

'변수'는 특수 내부 객체인 `환경 레코드`의 프로퍼티일 뿐이다. '변수를 가져오거나 변경'하는 것은 '환경 레코드의 프로퍼티를 가져오거나 변경'함을 의미한다.<br>

아래 두 줄짜리 코드엔 렉시컬 환경이 하나만 존재한다.

<img src="../img/6-3/lexical-environment.png">

이렇게 스크립트 전체와 관련된 렉시컬 환경은 전역 렉시컬 환경(Global Lexical Environment)라고 한다.

위 그림에서 네모 상자는 변수가 저장되는 환경 레코드를 나타내고 붉은 화살표는 외부 렉시컬 환경에 대한 참조를 나타낸다.

전역 렉시컬 환경은 외부 참조를 갖지 않기 때문에 화살표가 `null`을 가리키는걸 알 수 있다.<br>

코드가 실행되고 실행 흐름이 이어져 나가면서 렉시컬 환경은 변화된다.

좀 더 긴 코드를 보자

<img src="../img/6-3/lexical-environment2.png">

우측의 네모 상자들은 코드가 한 줄, 한 줄 실행될 때 마다 전역 렉시컬 환경이 어떻게 변화하는지 보여준다.

1. 스크립트가 시작되면 스크립트 내에서 선언한 변수 전체가 렉시컬 환경에 올라간다.(pre-populated)
   * 이 때 변수의 상태는 특수 내부 상태(Special Internal State)인 'uninitialized'가 되나. JS 엔진은 uninitialized 상태의 변수를 인지하긴 하지만, `let`을 만나기 전까진 이 변수를 참조할 수 없다.
2. `let phrase`가 나타났다. 아직 값을 할당하기 전이기 때문에 프로퍼티의 값은 `undefined`이다. `phrase`는 이 시점부터 사용할 수 있다.
3. `phrase`에 값이 할당됐다.
4. `phrase`에 값이 변경됐다.

아직까지는 어려운게 없다<br>

> <h2>렉시컬 환경은 `spec`에만 존재한다.</h2>
> '렉시컬 환경'은 `Specification`에서 JS가 어떻게 동작하는지 설명하는 데에 쓰이는 '이론상의' 객체이다. 따라서 코드를 사용해 직접 렉시컬 환경을 얻거나 조작하는 것은 불가능하다.
>
> JS 엔진들은 `spec`에 언급된 사항들을 준수하면서 엔진 고유의 방법을 사용해 렉시컬 환경을 최적화한다. 사용하지 않는 변수를 버려 메모리를 절약하거나 다양한 내부 트릭을 사용하는 식으로

<h3>2. 함수 선언문</h3>

함수는 변수와 마찬가지로 값이다.

다만 **함수 선언문으로 선언한 함수는 일반 변수와는 달리 바로 초기화된다**는 점에서 차이가 있다.

함수 선언문으로 선언한 함수는 렉싴러 환경이 만들어지는 즉시 사용할 수 있다. (변수는 `let`을 만나 선언이 될 때 까지 사용할 수 없다.)

선언되기 전에도 함수를 사용할 수 있는 것은 바로 이 때문<br>

아래 그림은 스크립트에 함수를 추가했을 때 전역 렉시컬 환경 초기 상태가 어떻게 변화하는지 보여준다.

<img src="../img/6-3/lexical-environment3.png">

이런 동작 방식은 함수 선언문으로 정의한 함수에만 적용된다. `let say = fuction(name){...}` 같이 함수를 변수에 할당한 **함수 표현식은 해당되지 않는다.**

<br>

<h3>3. 내부와 외부 렉시컬 환경</h3>

함수를 호출해 실행하면 새로운 렉싴러 환경이 자동으로 만들어진다. 이 렉시컬 환경에서는 함수 호출 시 넘겨받은 매개 변수와 함수의 지역 변수가 저장된다.

`say('John')`을 호출하면 아래와 같은 내부 변화가 일어난다.(현재 실행 흐름을 붉은색 화살표로 나타낸 줄에 멈춰있는 상태)

<img src="../img/6-3/lexical-environment4.png">

함수가 호출 중인 동안엔 호출 중인 함수를 위한 내부 렉시컬 환경과 내부 렉시컬 환경이 가리키는 외부 렉시컬 환경을 갖게 된다.

* 예시의 내부 렉시컬 환경은 현재 실행중인 함수인 `say()`에 상응한다. 내부 렉시컬 환경엔 함수의 인자인 `name`으로부터 유래한 프로퍼티 하나만 있ㄷ. `say('John')`을 호출했기 때문에, `name`의 값은 `'John'`이 된다.
* 예시의 욉 렉싴러 환경은 전역 렉시컬 환경이다. 전역 렉시컬 환경은 `phrase`와 함수 `say()`를 프로퍼티로 갖는다.

그리고 **내부 렉시컬 환경은 외부 렉시컬 환경에 대한 참조를 갖는다.**

**코드에서 변수에 접근할 때는 우선 내부 렉시컬 환경을 검색 범위로 잡는다. 내부 렉시컬 환경에서 원하는 변수를 찾지 못하면 검색 범위를 내부 렉시컬 환경이 참조하는 외부 렉시컬 환경으로 확장하나. 이 과정은 검색 범위가 전역 렉시컬 환경으로 확장될 때 까지 반복됨.**

전역 렉시컬 환경에 도달할 때 까지 변수를 찾지 못하면 엄격 모드에서는 에러를 발생시킴. 엄격 모드가 아니라면 새로운 전역 변수가 만들어진다(하위 호환성을 위해 남아있는 기능임)

예시와 그림을 보며 변수 검색이 어떻게 진행되는지 정리하면

* 함수 `say()` 내부의 `alert()`에서 변수 `name`에 접근할 땐, 먼저 내부 렉시컬 환경을 살펴본다. 내부 렉시컬 환경에서 `name`을 찾았다.
* 그 다음 `alert()`에서 변수 `phrase`에 접근하려는데, `phrase`가 내부 렉시컬 환경에는 없다. 따라서 검색 범위를 외부 렉시컬 환경을 확장시켰더니 있다!

<img src="../img/6-3/lexical-environment5.png">

<br>

<h3>4. 함수를 반환하는 함수</h3>

`makeCounter()` 예시로 돌아가봅시다...

```js
function makeCounter() {
  let count = 0;

  return function() {
    return count++;
  }
}

let counter = makeCounter();
```

`makeCounter()`를 호출하면 호출할 때마다 새로운 렉시컬 환경 객체가 만들어지고 여기에 `makeCounter()`를 실행하는데 필요한 변수들이 저장된다.

위쪽에서 살펴본 `say('John')` 예시와 마찬가지로 `makeCounter()`를 호출할 때도 두 개의 렉시컬 환경이 만들어진다.

<img src="../img/6-3/lexical-environment6.png">

그런데 위쪽에서 사려본 `say('John')` 예시와 `makeCounter()` 예시에는 차이점이 하나 있다.

`makeCounter()`가 실행되는 도중엔 본문(`return count++`)이 한 줄 짜리인 중첩 함수가 만들어진다는 점이다. 현재는 중첩 함수가 생성되기만 하고 실행은 되지 않은 상태<br>

여기서 중요한 사실이 하나 있다. 모든 함수는 함수가 생성된 곳의 렉시컬 환경을 기억한다는 점이다. 함수는 `[[Environment]]`라 불리는 숨김 프로퍼티를 갖는데, 여기에 함수가 만들어진 곳의 렉시컬 환경에 대한 참조가 저장된다.

<img src="../img/6-3/lexical-environment7.png">

따라서 `counter.[[Environment]]`엔 `{count: 0}`이 있는 렉시컬 환경에 대한 참조가 저장된다. 호출 장소와 상관없이 함수가 자신이 태어난 곳을 기억할 수 있는건 바로 이 `[[Environment]]` 프로퍼티 덕분이다.

`[[Environment]]`에 저장된 렉시컬 환경을 외부 렉시컬 환경으로서 참조한다.

<img src="../img/6-3/lexical-environment8.png ">

실행 흐름이 중첩 함수의 본문으로 넘어오면 `count` 변수가 필요한데, 먼저 자체 렉시컬 환경에서 변수를 찾는다. 익명 중첩 함수엔 지역 변수가 없기 때문에 이 렉시컬 환경은 비어있는 상황이다. `<empty>`. 이제 `counter()`의 렉시컬 환경이 참조하는 외부 렉시컬 환경에서 `count`를 찾는다.

이제 `count++`가 실행되면서 count 값이 1 증가해야 하는데, **변수 값 갱신은 변수가 저장된 렉시컬 환경에서 이루어진다.**<br>

따라서 실행이 종료된 후의 상태는 다음과 같다.

<img src="../img/6-3/lexical-environment9.png ">

`counter()`를 여러 번 호출하면 `count`가 `2`, `3`으로 증가하는 이유가 바로 여기에 있다.

> <h2>클로저</h2>
> `클로저(closure)`는 개발자라면 알고 있어야 할 프로그래밍 용어이다.
>
> 클로저는 외부 변수를 기억하고 이 외부 변수에 접근할 수 있는 함수를 의미한다. 몇몇 언어에서는 클로저를 구현하는게 불가능하거나 특수한 방식으로 함수를 작성해야 클로저를 만들 수 있다. 하지만 JS에서는 모든 함수가 자연스럽게 클로저가 된다. 예외가 하나 있긴한데 `new Function`에서 다루도록 함
>
> **요점**: JS의 함수는 숨김프로퍼티인 `[[Environment]]`를 이용해 자신이 어디서 만들어졌는지 기억한다. 함수 본문에서는 `[[Environment]]``를 사용해 외부 변수에 접근한다.

<h3>가비지 컬렉션</h3>

함수 호출이 끝나면 함수에 대응하는 렉시컬 환경이 메모리에서 제거된다. 함수와 관련된 변수들은 이때 모두 사라진다. (함수 호출이 끝나면 관련 변수를 참조할 수 없는 이유이기도 함) JS에서 모든 객체는 도달 가능한 상태일 때만 메모리에 유지된다.

그런데 호출이 끝난 후에도 여전히 도달 가능한 중첩 함수가 있을 수 있다. 이 때는 이 중첩 함수의 `[[Environment]]` 프로퍼티에 외부 함수 렉시컬 환경에 대한 정보가 저장된다. (도달 가능한 상태가 되는 것)

ex)

```js
function f() {
  let value = 123;
  
  return function() {
    alert(value);
  }
}

let g = f(); // g.[[Environment]]에 f() 호출 시 만들어지는 렉시컬 환경 정보가 저장된다.
```

이렇게 중첩 함수를 사용할 때에는 주의해야 할 점이 있다.

`f()`를 여러 번 호출하고 그 결과를 어딘가에 저장하는 경우, 호출 시 만들어지는 각 렉시컬 환경 모두가 메모리에 유지된다는 점이다. 아래 예시를 실행하면 3개의 렉시컬 환경이 만들어지는데, 각 렉시컬 환경은 메모리에서 삭제되지 않는다.

```js
function f() {
  let value = Math.random();
  
  return function() { alert(value); };
}

// 배열 안의 세 함수는 각각 f()를 호출할 때 생성된 렉시컬 환경과 연관 관계를 맺는다.

let arr = [f(), f(), f()];
```

렉시컬 환경 객체는 다른 객체와 마찬가지로 도달할 수 없을 때 메모리에서 삭제된다. 해당 렉시컬 환경 객체를 참조하는 중첩 함수가 하나라도 있으면 사라지지 않는다.

아래 예시같이 중첩 함수가 메모리에서 삭제되고 난 후에야, 이를 감싸는 렉시컬 환경(그리고 그 안의 변수인 `value`)도 메모리에서 제거된다.

```js
function f() {
  let value = 123;

  return function() {
    alert(value);
  }
}

let g = f(); // g가 살아있는 동안엔 연관 렉시컬 환경도 모두 메모리에 살아있다

g = null; // 끊어버리면 그때서야 메모리에서 제거됨
```

<br>

<h4>최적화 프로세스</h4>

앞에서 보았듯이, 함수가 살아있는 동안엔 이론상으론 모든 외부 변수 역시 메모리에 유지된다.

그러나 실제로는 JS 엔진이 이를 지속해서 최적화한다. JS 엔진은 변수 사용을 분석하고 외부 변수가 사용되지 않는다고 판단되면 이를 메모리에서 제거한다.

**디버깅 시, 최적화 과정에서 제거된 변수를 사용할 수 없다는 점은 V8 엔진의 주요 부작용이다.**

