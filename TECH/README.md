# 면접 대비 질문 리스트

> RESTful API에 대해 설명해주세요.

- 웹에서 자원을 표현하고 상태를 전송하기 위한 하나의 약속이다. HTTP 프로토콜을 사용하여 클라이언트와 서버간의 통신을 가능하게 한다.

1. 자원(Resource): 모든 것이 자원으로 표현된다. ex) 사용자, 게시물, 주문, 등 모든 개체는 자원으로 간주됨
2. 표현(Representation): 자원은 여러 표현으로 표현될 수 있다. 일반저긍로 JSON, XML 또는 HTMl과 같은 형식으로 표현된다. 클라이언트는 요청에 따라 원하는 표현을 선택할 수 있다.
3. 상태(State): 클라이언트와 서버 간의 상호 작용은 상태를 전송한다. 상태는 요청에 대한 응답으로 반환되거나, 클라이언트가 요청을 통해 변경할 수 있다.
4. HTTP Method: RESTful API에서는 HTTP 메서드를 사용하여 자원에 대한 CRUD를 정의한다. 가장 일반적으로 사용되는 메서드는 다음과 같다.
	- GET: 자원을 조회한다.
	- POST: 새로운 자원을 생성한다.
	- PUT: 자원을 업데이트한다.
	- DELETE: 자원을 삭제한다.
5. URI(Uniform Resource Identifier): 각 자원은 고유한 URI를 갖는다. 클라이언트는 URI를 사용하여 특정 자원을 식별하고 요청할 수 있다.
6. 무상태성: RESTful API는 상태를 저장하지 않고, 각 요청을 모든 필요한 정보를 포함한다. 이는 서버 츠겡서 클라이언트의 상태를 관리하지 않으므로 확장성이 용이하다.
7. 캐싱: RESTful API는 HTTP의 캐싱 매커니즘을 활용하여 응답을 캐시할 수 있다. 이는 성능을 향상시키고, 네트워크 부하를 줄일 수 있다.
8. 계층 구조(Layered System): RESTful API는 계층 구조를 가질 수 있다. 클라이언트는 서버와 직접 통신하는 대신 중간 계층을 통해 통신할 수 있다.
	- 예를 들면 API는 server A에 실행, data는 server B에 저장, 요청을 검증하는 것은 server C에서 하는 것을 허용. 클라이언트는 end server에 연결되었는지 매개체에 연결되었는지 알 수 없다.

> 프레임워크와 라이브러리의 차이에 대해서 설명해보세요.

1. 프레임워크
	- 프레임워크는 소프트웨어 개발을 위한 구조와 규칙을 제공하는 추상화된 툴이다.
	- 일반적으로 애플리케이션의 전체 구조를 제어하고, 개발자가 필요한 부분을 채우도록 한다.
	- 프레임워크는 보통 특정한 문제를 해결하기 위한 툴로서, 특정한 개발 패러다임이나 설계 원칙을 따르며, 해당 프레임워크가 제공하는 규칙과 규약을 따라야 한다.
	- Spring, Nest.js, Express.js, Django 등이 있다.
2. 라이브러리
	- 라이브러리는 재사용 가능한 코드 조각으로, 특정한 기능을 수행하기 위한 함수, 클래스, 모듈 등의 집합이다.
	- 개발자가 필요한 기능을 호출하여 사용한다. 개발자는 제어의 흐름을 직접 제어하며, 필요한 라이브러리를 필요한 시점에 가져와 사용할 수 있다.
	- 라이브러리는 보통 특정한 기능을 제공하기 위해 설계되며, 다양한 문제에 대한 해결책으로 사용될 수 있다.

3. 주요한 차이점
	- 제어 흐름:
		- 프레임워크는 개발자에게 제어의 흐름을 제공하며, 개발자는 프레임워크에 따라 코드를 작성한다. -> 프레임워크가 개발자 위에 있다.
		- 라이브러리는 개발자가 직접 제어의 흐름을 조절하며, 필요할 때만 라이브러리를 호출하여 사용한다.
	- 의존성:
		- 프레임워크는 개발자가 프레임워크의 규칙과 규약을 따라야 하므로, 개발자는 프레임워크에 의존하게 된다.
		- 라이브러리는 개발자가 필요할 때만 호출하여 사용하므로, 개발자는 라이브러리에 의존하지 않고도 개발을 진행할 수 있다.
	- 확장성:
		- 프레임워크는 제공하는 규칙과 규약을 따르는 선에서 확장이 가능하다.
		- 라이브러리는 개발자가 필요한 시점에 호출하여 사용하기 때문에, 개발자에게 달려있다.

> GET과 POST의 차이는 무엇인가요?

1. 용도: 
	- GET: 리소스를 요청하기 위해 사용한다. 주로 데이터를 서버로 보내지 않고 서버로부터 데이터를 가져오기 위해 사용한다.
	- POST: 리소스를 생성하거나 업데이트하기 위해 사용한다.
2. 데이터 전송 방식:
	- GET: 데이터는 URL의 쿼리 스트링에 포함되어 전송된다. 데이터는 주소 표시줄에 노출되며, 길이에 제한이 있다.
	- POST: 데이터는 HTTP 요청의 바디에 포함되어 전송된다. 데이터는 사용자에게 노출되지 않으며, 길이에 제한이 없다.
3. 캐싱:
	- GET: 응답은 캐시될 수 있다. 동일한 요청이 다시 발생할 때 이전에 받은 응답을 재사용할 수 있따.
	- POST: 응답은 캐시되지 않는다. POST 요청은 일반적으로 상태를 변경하므로 캐싱이 적용되지 않음
4. 안전성:
	- GET: 요청이 브라우저의 주소 표시줄에 노출되므로 민감한 데이터(비밀번호 등)를 전송하는데 적합하지 않다.
	- POST: 요청의 데이터는 바디에 포함되어 있으므로 GET보다 안전하다. 민감한 데이터를 전송하는데 적합하다.
5. 멱등성:
	- GET: 동일한 요청을 여러 번 보내더라도 서버의 상태에 변화를 일으키지 않는다.(== 멱등성이다)
	- POST: 동일한 요청을 여러 번 보내면 서버의 상태가 변경될 수도 있다.

> 객체지향 프로그래밍이란 무엇인가요?

- 현실 세계의 개념을 모델링하고 이를 소프트웨어 객체로 표현하여 문제를 해결하는 방법론이다. 이러한 객체는 데이터와 행위(메서드)를 함께 묶어서 캡슐화하고, 객체 간에 상호작용하며 프로그램을 구성한다.
- 주요 개념과 특징
	1. 클래스와 객체:
		- 클래스는 객체의 설계도라고 볼 수 있으며, 객체는 클래스의 인스턴스이다.
		- 클래스는 속성(데이터)와 메서드(행위)로 ㄱ성된다.
		- ex) Car Class는 model과 color field를 가지고 있으며, drive(), stop() method를 가지고 있다.
	2. 캡슐화:
		- 데이터와 그 데이터를 처리하는 메서드를 하나로 묶는 것을 말한다.
		- 클래스는 데이터를 숨기고 외부에서 직접 접근할 수 없도록 보호한다. 대신 메서드를 통해 데이터에 접근하고 조작한다.
	3. 상속:
		- 하나의 클래스가 다른 클래스의 특성(속성과 메서드)을 이어받는 것을 말한다.
		- 상속을 통해 코드의 재사용성을 높이고 계층적인 관계를 형성할 수 있다.
	4. 다형성:
		- 같은 메서드 이름을 사용하면서 각각의 객체에 따라 다르게 동작하도록 하는 개념이다.
		- 오버로딩, 오버라이딩을 통해 구현된다.
	5. 추상화:
		- 객체에서 중요한 특성을 강조하고 세부 사항을 숨기는 것을 말한다.
		- 즉, 객체의 공통된 특성을 추출하고 클래스로 정의하고, 다른 세부적인 부분은 숨기는 것을 의미한다.

> HTTP Method에 대해서 설명해보세요.

1. GET
	- 서버에서 특정 리소스의 표현을 요청한다.
	- 주로 데이터를 가져오는 데 사용된다.(Read Only)
	- 요청된 데이터는 URL의 쿼리 스트링에 포함될 수 있다.
2. POST:
	- 서버에 새로운 리소스를 생성하거나 데이터를 제출한다.
	- 주로 데이터를 전송하여 서버의 상태를 변경하거나 업데이트하는 데 사용된다(Write)
3. PUT:
	- 서버에 존재하는 리소스를 업데이트한다.
	- 전체 리소스를 교체한다. 즉, 클라이언트가 지정한 리소스로 대체된다.
4. PATCH:
	- 서버에 존재하는 리소스의 일부를 업데이트한다.
	- 일부만 변경하고 나머지는 그대로 유지한다.
5. DELETE:
	- 서버에서 특정 리소스를 삭제한다.
	- 해당 리소스를 삭제하고 응답은 삭제 결과를 나타낸다.
6. HEAD:
	- GET 요청과 동일하지만, 응답에서 본문(body)을 제외하고 헤더 정보만을 반환한다.
	- 주로 헤더 정보를 가져와 리소스의 메타 데이터를 확인하는 데 사용된다.
7. OPTIONS:
	- 서버에서 지원되는 HTTP 메서드를 확인하거나 리소스에 대한 지원되는 메서드 옵션을 요청한다.
	- CORS(Cross-Origin Resource Sharing) 요청 시 브라우저에서 자동으로 OPTIONS 요청을 전송한다.
8. TRACE:
	- 클라이언트에서 서버까지의 경로를 따라 메시지 루프백을 요청한다.
	- 주로 디버깅 및 진단 목적으로 사용된다.
9. CONNECT:
	- 목적지 서버로의 프록시 연결을 설정한다.
	- 주로 SSL/TLS와 함께 사용되어 안전한 터널을 설정하는 데 사용된다.

> HTTP 상태 코드에 대해 설명해보세요.

- 클라이언트가 보낸 요청에 대한 서버의 응답을 나타내는 세 자리 숫자로 이루어진 콛이다. 이 코드는 요청이 성공했는지, 실패했는지, 그 이유가 무엇인지 등을 나타낸다. HTTP Status Code는 다양한 범주에 속하며, 각각의 범주는 특정한 의미와 응답 형식을 가진다.

1. 1xx(Informational, 정보)
	- 요청이 수신되었고 처리가 진행 중인 상태를 나타낸다.
2. 2xx(Success, 성공)
	- 요청이 성공적으로 처리되었음을 나타낸다.
	- 가장 많이 사용되는 코드는 200(ok)
3. 3xx(Redirection, 리다이렉션)
	- 요청을 완료하기 위해 추가 동작이 필요함을 나타낸다.
	- ex)리소스가 새 위치로 이동되었음을 나타내는 301(Moved Permanently)
4. 4xx(Client Error, 클라이언트 오류)
	- 클라이언트 측에서 발생한 오류를 나타낸다.
	- ex) 잘못된 요청을 나타내는 400(Bad Request)
5. 5xx(Server Error, 서버 오류)
	- 서버 측에서 발생한 오류를 나타낸다.
	- ex) 서버에서 처리할 수 없는 요청이 도착했음을 나타내는 500(Internal Server Error)

> 프로세스와 스레드의 차이에 대해 설명해보세요.

1. 정의:
	- 프로세스: 운영 체제에서 실행 중인 프로그램을 의미한다. 각 프로세스는 독립적인 메모리 공간을 가지며, 운영 체제는 각 프로세스에게 자원을 할당한다.
	- 스레드: 프로세스 내에서 실행되는 실행 단위를 의미한다. 한 프로세스 내에서 여러 개의 스레드가 동시에 실행될 수 있으며, 스레드는 해당 프로세스의 메모리 공간을 공유한다.
2. 자원 공유:
	- 프로세스: 각 프로세스는 독립적이 메모리 공간을 가지므로, 프로세스 간의 자원 공유는 별도의 매커니즘이 필요하다. 일반적으로 프로세스 간의 통신(IPC)를 사용하여 데이터를 교환한다.
	- 스레드: 한 프로세스 내의 스레드는 같은 메모리 공간을 공유하기 때문에, 스레드 간의 자원 공유가 더 간단하다. 이로 인해 스레드 간의 통신이 더욱 효율적으로 이루어짐
3. 생성 비용:
	- 프로세스: 프로세스를 생성하는 데는 상당한 시스템 리소스가 필요하므로, 프로세스 생성에는 상대적으로 높은 비용이 든다.
	- 스레드: 스레드는 프로세스 내에서 생성되므로 프로세스 생성보다 훨씬 적은 시스템 리소스가 필요하다. 따라서 스레드의 생성 비용은 상대적으로 낮다.
4. 병행성:
	- 프로세스: 각 프로세스는 독립적으로 실행되므로, 프로세스 간의 병행성을 달성하기 위해서는 별도의 매커니즘이 필요하다.
	- 스레드: 한 프로세스 내의 스레드는 공유된 메모리 공간을 가지므로, 스레드 간의 병행성을 달성하기가 더욱 쉽다.
5. 동기화:
	- 프로세스: 프로세스 간의 동기화는 별도의 IPC(Inter-Process Communication) 매커니즘이 필요하다.
	- 스레드: 스레드 간의 동기화는 프로세스 내에서 공유된 자원을 직접 접근할 수 있으므로, 동기화가 간단하다.

> RDBMS와 NoSQL의 차이에 대해 설명해보세요.

1. 데이터 모델:
	- RDBMS: 관계형 데이터 모델을 사용한다. 데이터는 테이블의 형태로 구성되며, 각 테이블은 행과 열의 조합으로 이루어진다. 테이블 간의 관계는 외래 키를 사용하여 정의한다.
	- NoSQL: 다양한 데이터 모델을 사용할 수 있다. 주로 문서(document), 키-값(key-value), 그래프(graph), 와이드 컬럼(wide-column)등의 모델을 사용한다.
2. 스키마:
	- RDBMS: 정적인 스키마(static schema)를 사용한다. 데이터의 구조는 미리 정의되고 변경하기 어렵다.
	- NoSQL: 동적인 스키마(dynamic schema)를 사용한다. 데이터 구조는 유연하며, 필요에 따라 동적으로 변경할 수 있다.
3. 확장성:
	- RDBMS: 수직적 확장(vertical scaling)을 사용하여 서버의 성능을 향상시킨다. 단일 서버의 성능을 높임
	- NoSQL:수평적 확장(horizontal scaling)을 사용하여 시스템의 성능을 향상시킨다. 여러 대의 서버를 추가하여 시스템을 확장시킴
4. 트랜잭션 처리:
	- RDBMS: ACID(Atomicity, Consistency, Isolation, Durability) 트랜잭션을 지원한다. 데이터 일관성과 안정성을 보장하기 위해 트랜잭션 처리가 중요하다.
	- NoSQL: 일부 NoSQL 데이터베이스는 ACID 트랜잭션을 제공하지만, 다수의 NoSQL 시스템은 유연성과 확장성을 위해 일관성 모델을 제한하거나 제공하지 않을 수 있다.
5. 용도: 
	- RDBMS:복잡한 쿼리와 데이터 분석을 위해 사용된다. 전통적인 엔터프라이즈 애플리케이션에서 널리 사용된다.
	- NoSQL: 대용량의 비정형 데이터를 처리하거나 실시간 처리, 웹 및 모바일 애플리케이션에서 사용된다. Big Data 및 IoT(Internet of Things)와 같은 빠르게 성장하는 데이터 요구 사항에 대응할 수 있다.
- 요약
	- RDBMS: 데이터 일관성과 안정성을 중시하는 전통적인 데이터베이스 시스템
	- NoSQL: 유연성과 확장성을 강조하는 새로운 유형의 데이터베이스 시스템

> CORS(Cross-Origin Resource Sharing)에 대해 설명해보세요.

- 웹 애플리케이션에서 다른 출처로부터 리소스를 요청할 때 발생하는 보안 정책을 우회하는 매커니즘이다. 웹 애플리케이션은 보안상의 이유로 동일 출처 정책(Same-Origin Policy)에 따라 다른 출처로부터 온 리소스에 접근할 수 없는데, CORS는 이 정책을 유연하게 해제하여 다른 출처의 리소스에 접근할 수 있도록 한다.

- 다음과 같은 상황에서 사용한다.
	1. AJAX 요청: 웹 애플리케이션에서 XMLHttpRequest나 Fetch API 등을 사용하여 다른 출처의 데이터를 요청할 때
	2. Web Fonts, Stylesheets, Scripts, Images 등의 리소스 요청: 웹 페이지에서 다른 출처의 리소스를 가져와 사용할 때
	3. API 호출: 웹 애플리케이션의 RESTful API등의 서비스로부터 데이터를 가져올 때

- CORS는 다음과 같은 단계로 작동한다.
	1. 요청 전송: 클라이언트에서 다른 출처로 요청을 보낸다.
	2. 옵션(pre-flight) 요청: 일부 요청은 브라우저에서 사전 요청(pre-flight)을 보낸다. 이는 실제 요청 전에 서버가 허용하는 메서드 및 헤더를 확인하기 위함이다.
	3. 응답: 서버는 요청을 처리하고, 요청에 대한 응답을 보낸다. 응답에는 CORS 정책에 대한 정보가 포함된다.
	4. 자원 전송: 클라이언트가 서버의 응답을 받고, 필요한 경우 요청한 리소스를 처리한다.

- Access-Control-Allow-Origin: 서버에서 클라이언트로 온 요청을 허용하는 출처를 나타낸다.
- Access-Control-Allow-Methods: 서버에서 허용되는 HTTP 메서드를 나타낸다.

> OAuth 2.0의 흐름에 대해 설명해보세요.

- OAuth 2.0은 클라이언트 애플리케이션이 사용자의 인증 정보를 안전하게 관리하고, 제3자 서비스의 리소스에 접근할 수 있도록 하는 프로토콜이다.
-  대략적 흐름
	1. 애플리케이션 등록: 클라이언트 애플리케이션은 인증 서버에 등록된다. 이 과정에서 클라이언트 아이디와 클라이언트 시크릿이 발급된다.
	2. 인가 코드 요청: 클라이언트 애플리케이션은 사용자를 인증 서버로 리디렉션한다. 이 때 클라이언트 아이디와 요청하는 스코프(권한)을 함께 전달한다.
	3. 사용자 로그인: 사용자는 인증 서버에 로그인하고, 요청도니 스코프에 대한 권한을 부여할지 여부를 결정한다.
	4. 인가 코드 발급: 사용자가 권한을 부여하면, 인증 서버는 클라이언트 애플리케이션에게 인가 코드를 발급한다.
	5. 액세스 토큰 요청: 클라이언트 애플리케이션은 인가 코드를 사용하여 인증 서버에 액세스 토큰을 요청한다.
	6. 액세스 토큰 발급: 인증 서버는 클라이언트 애플리케이션에게 액세스 토큰을 발급한다.
	7. 리소스 서버 저근: 클아이너트 애플리케이션은 발급받은 액세스 토큰을 사용하여 제3자 리소스 서버에 접근하고, 요청한 리소스를 받아온다

> 마이크로 서비스와 모놀리틱 서비스의 차이를 설명해보세요.

1. 모놀리틱 서비스:
	- 전통적인 단일 애플리케이션으로, 하나의 코드 베이스와 단일 실행 파일로 구성된다.
	- 모든 서비스 컴포넌트는 같은 코드 베이스에 포함되어 있으며, 하나의 데이터베이스에 의해 관리된다.
	- 애플리케이션을 변경하거나 배포할 때 전체 애플리케이션을 다시 빌드하고 배포해야 한다.
	- 개발, 테스트, 배포가 단순하고 관리가 용이하다.
	- 사이즈가 커지면 확장성과 유연성이 제한된다.
2. 마이크로 서비스:
	- 애플리케이션을 작은, 독립적인 서비스로 분해한다. 각 서비스는 자체적으로 독립적으로 배포할 수 있다.
	- 각 마이크로 서비스는 고유한 코드 베이스와 데이터베이스를 가지며, 특정 비즈니스 기능이나 기술적 책임을 담당한다.
	- 서비스 간 통신은 네트워크를 통해 이루어지며, 주로 API를 통해 이루어진다.
	- 애플리케이션을 변경할 때 필요한 서비스만 다시 빌드하고 배포할 수 있으므로 배포가 더욱 빠르고 유연하다.
	- 개발 팀 간 독립성이 높아져, 각 팀은 자유롭게 선택한 기술 스택과 개발 방법론을 사용할 수 있다.
	- 분산 시스템이므로 관리가 복잡할 수 있다.

> 세션과 쿠키의 차이를 설명해보세요.

1. 저장 위치:
	- 쿠키: 클라이언트 측에 저장된다. 쿠키는 클라이언트의 웹 브라우저에 텍스트 형태로 저장된다.
	- 세션: 서버 측에 저장된다. 세션은 서버 메모리가 데이터베이스에 저장된다.
2. 용도:
	- 쿠키: 주로 클라이언트의 상태를 유지하기 위해 사용한다. 예를 들어 사용자의 로그인 상태를 유지하거나 사용자의 선호 설정을 저장하는 데에 사용한다.
	- 세션: 클라이언트의 상태를 서버에 유지하기 위해 사용한다. 주로 사용자의 인증 상태를 관리하거나 사용자의 상태를 추적하는 데 사용한다.
3. 보안:
	- 쿠키: 클라이언트 측에 저장되므로 보안에 취약할 수 있다. 민감한 정보를 저장할 때 문제가 발생할 수 있음
	- 세션: 서버 측에 저장되므로 상대적으로 안전하다. 민감한 정보를 서버에 저장하고 처리하기 때문에 보안성이 높음
4. 수명:
	- 쿠키: 설정된 만료 날짜나 기간에 따라 지정된 시간 동안 유지된다. 만료 날짜가 설정되지 않으면 브라우저가 닫힐 때 까지 유지된다.
	- 세션: 사용자가 브라우저를 닫거나 로그아웃할 때 까지 유지된다. 일반적으로 세션은 일정 시간 동안 유지되고, 세션 유효 시간이 지나면 만료된다.
5. 용량 제한:
	- 쿠키: 도메인당 쿠키의 수 및 쿠키의 크기에 제한이 있다. 일반적으로 한 도메인에는 최대 몇 개의 쿠키를 가질 수 있으며, 각 쿠키는 일정한 크기를 초과할 수 없다.
	- 세션: 서버 측에 저장되므로 일반적으로 용량 제한이 없다. 그러나 서버 메모리나 데이터베이스의 용량에 따라 제한될 수 있다.

> CI/CD란 무엇인지 설명해보세요.

-  소프트웨어 개발 및 배포 프로세스의 자동활르 위한 개념이다. 'Conitinuous Integration(지속적 통합)'과 'Continuous Deployment(지속적 배포) | Continuous Delivery(지속적 제공)'의 약자이다. 이 두 가지 개념은 함께 사용되어 개발자 및 팀이 소프트웨어를 효율적으로 빠르게 빌드, 테스트, 배포할 수 있도록 지원한다.

1. CI:
	- 개발자가 코드를 공유 레포지토리에 push할 때 마다 자동으로 코드의 통합, 빌드, 테스트를 수행하는 개발 방법론
	- 여러 개발자가 동시에 작업하는 경우 코드 충돌을 방지하고, 통합된 코드가 신속하게 테스트되어 품질을 유지할 수 있다.
	- 주로 자동화된 빌드 및 테스트 파이프라인을 통해 구현된다.
2. CD:
	1. Continuous Delivery(지속적 제공):
		- 소프트웨어를 빌드 및 테스트한 후에 자동으로 프로덕션 환경으로 제공할 수 있는 프로세스이다.
		- Continuous Delivery를 통해 개발된 소프트웨어는 언제든지 프로덕션 환경에 배포할 수 있또록 준비된다. 그러나 실제 배포는 수동으로 이루어질 수도 있다.
		- 소프트웨어의 배포 과정을 자동화하고, 배포 시간을 단축하며, 신속한 피드백을 통해 빠른 개선을 가능하게 한다.
	2. Continuous Deploy(지속적 배포):
		- Continuous Delivery의 한 형태로, 모든 변경 사항이 프로덕션 환경으로 자동으로 배포되는 것을 의미한다.
		- CD의 가장 극단적인 형태로, 테스트를 통과한 모든 코드가 즉시 프로덕션 환경에 배포되어 사용자에게 실시간으로 제공된다.
		- 릴리스 주기를 단축하고, 빠른 사용자 피드백을 통해 소프트웨어의 품질을 높일 수 있다.

> Call By Value와 Call By Reference의 차이에 대해 설명해보세요.

- 둘은 모두 함수 호출 시 인수를 전달하는 방식을 나타내는 용어이다. 차이는 매개 변수를 전달하는 방식에서 차이가 있다.

1. Call By Value(값에 의한 호출):
	- 함수에 매개 변수를 전달할 때, 해당 매개 변수의 값이 복사되어 전달된다.
	- 따라서 함수 내에서 매개 변수의 값이 변경되어도 호출된 곳의 변수 값은 변경되지 않는다.
	- Call By Value 방식은 주로 기본 데이터 타입(정수, 실수, 문자열 등)을 전달할 때 사용된다.
```ts
const changeValue = (x: number) => {
	x = 10;
}
const value = 5;

changeValue(value);

console.log(value); // 5 (변수의 값은 변경되지 않음)
```

2. Call By Reference(참조에 의한 호출):
	- 함수에 매개 변수를 전달할 때, 해당 매개 변수의 메모리 주소(참조)가 전달된다.
	- 따라서 함수 내에서 매개 변수의 값을 변경하면 호출된 곳의 변수 값도 변경된다.
	- 객체나 배열과 같은 참조 타입을 전달할 때 사용된다.
```ts
const changeList = (list: any[]) => {
	list.push(4);
}

const anyList = [1, 2, 3];
changeList(anyList);

console.log(anyList); // [1, 2, 3, 4];
```


> 클로져(Closure)에 대해 설명해보세요.


> MVC 아키텍쳐에 대해 설명해보세요.

> RESTful API와 GraphQL의 차이는 무엇인가요?

> JWT(JSON Web Token)에 대해 설명해주세요.

> 컴파일러와 인터프리터의 차이는 무엇인가요?

> 동기식과 비동기식 프로그래밍의 차이를 설명해보세요.

> 컨테이너와 가상머신의 차이는 무엇인가요?

> 소프트웨어의 생명 주기에 대해 설명해주세요.

> 디자인 패턴이 무엇이고 어떻게 유용한가요?

> DB에서 인덱스를 잘 사용하면 어떤 장점이 있나요?

> 절차 지향 프로그래밍과 객체 지향 프로그래밍의 차이점에 대해 설명해보세요.

