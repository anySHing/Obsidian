# 면접 대비 질문 리스트

> node가 싱글 스레드인데도 여러가지 병렬 작업이 되는 이유를 알려주세요.

- Node.js는 싱글 스레드 이벤트 루프 기반의 비동기 I/O 모델을 사용한다.

1. 비동기 I/O:
	- Node.js는 비동기 I/O를 기본으로 지원한다. 따라서 파일 시스템 액세스, 네트워크 요청 등의 I/O 작업은 블로킹하지 않고 비동기적으로 처리된다. 이러한 작업은 백그라운드에서 수행되며, 작업 완료 시 콜백 함수가 호출되어 이벤트 루프에 의해 처리된다.
2. 이벤트 루프:
	- Node.js의 이벤트 루프는 단일 스레드에서 이벤트 처리를 관리한다. 이벤트 루프는 비동기 작업이 완료되었을 때 해당 작업을 처리하고 콜백 함수를 실행한다. 이를 통해 여러 개의 I/O 작업을 동시에 처리할 수 있다.
3. 논 블로킹 I/O:
	- Node.js는 논 블로킹 I/O 모델을 사용하여 여러 작업을 동시에 처리할 수 있다. 따라서 하나의 요청이 완료될 때 까지 기다리는 대신, 다른 작업을 처리할 수 있다. 이를 통해 CPU 자원을 효율적으로 활용할 수 있다.
4. Worker Threads:
	- Node.js v10.5.0 버전부터 Worker Threads 기능이 도입되었다. 이를 사용하면 JavaScript를 사용하여 백그라운드에서 병렬 작업을 수행할 수 있다. 이를 통해 CPU 집약적인 작업을 처리하는 동안 메인 이벤트 루프를 블로킹하지 않고 계속하여 다른 작업을 처리할 수 있다.

> CPU 부하가 큰 작업이 진행돼서 이벤트 루프에 묶여 서버가 멈추면 어떻게 해결해야하나요?

1. 비동기 작업 분리: CPU 집약적인 작업을 수행할 때는 이를 비동기적으로 처리하고, 이벤트 루프를 블로킹하지 않도록 한다. 이를 위해 Worker Threads나 클러스터링을 사용하여 작업을 백그라운드에서 병렬로 처리할 수 있다.
2. 작업 분할: 큰 작업을 여러 작은 작업으로 분할하여 처리하고, 각 작업이 완료될 때 마다 이벤트 루프에 반환하여 처리한다. 이를 통해 CPU 부하를 분산하고, 이벤트 루프가 블로킹되는 상황을 방지할 수 있다.
3. 큐 및 우선 순위 설정: 작업을 처리하는 큐를 사용하여 작업을 관리하고, 우선 순위를 설정하여 중요한 작업이 먼저 처리되도록 한다. 이를 통해 이벤트 루프가 블로킹되는 상황을 최소화활 수 있다.
4. 타임아웃 설정: CPU 부하가 큰 작업에 타임아웃을 설정하여 일정 시간동안 작업이 완료되지 않으면 작업을 중단하고 에러 처리할 수 있도록 한다. 이를 통해 서버의 응답성을 유지하고, 더 큰 문제를 방지할 수 있다.
5. 서버 확장 및 부하 분산: 서버를 확장하여 부하를 분산하고, 로드 밸런싱을 활용하여 여러 서버 간의 작업을 고르게 분배한다. 이를 통해 단일 서버의 부하가 높아지는 상황을 방지하고, 전체 시스템의 안정성을 유지할 수 있다.

> 자바스크립트에서는 사용할 수 없지만 타입스크립트에서는 사용할 수 있는 것들은 무엇이 있나요?

1. 정적 타입 시스템: TS는 변수 함수 및 객체에 대한 명시적인 타입 정의를 제공한다 이를 통해 코드의 안전성과 가독성을 높일 수 있다.
```ts
const myNumber: number = 10;
const myString: string = 'hello';
```

2. 인터페이스: 객체의 구조를 정의하고, 해당 구조를 따르는 객체를 생성할 수 있도록 한다. 이를 통해 코드의 재사용성과 유지보수성을 높일 수 있다.
```ts
interface Person {
	name: string;
	age: number;
	sex?: 'M' | 'F';
}
```

3. 제네릭: 코드의 유연성을 높여주는 기능으로, 함수나 클래스에서 사용될 타입을 나중에 지정할 수 있도록 한다.
```ts
const identity<T> = (arg: T): T => {
	return arg;
}

const result = identity<string>('hello');
```

> 타입스크립트가 어떻게 자바스크립트로 컴파일해서 실행될 수 있는지 설명해보세요.

- 타입스크립트는 자바스크립트의 슈퍼셋(== 상위언어)이므로, 타입스크립트 코드는 자바스크립트 엔진이 이해할 수 있는 코드로 컴파일될 수 있다.

1. 타입스크립트 컴파일러(tsc): tsc를 사용하여 자바스크립트 코드로 변환된다. tsc는 타입 체크 및 코드 변환을 수행하여 타입 안전성을 유지하면서 자바스크립트 코드로 변환시킨다.
2. 타입 주석 제거 및 타입 추론: 타입스크립트는 타입 주석(Type Annotations)과 타입스크립트 고유의 문법을 포함하고 있따. 컴파일러는 이러한 타입 주석을 제거하고, 필요한 경우 타입 추론을 통해 변수 및 함수의 타입을 자동으로 결정한다.
3. ES3, ES5, ES6+ 호환성: 타입스크립트는 ECMAScript 표준을 준수하므로, ES3, ES5, ES6+와 같은 여러 버전의 자바스크립트로 컴파일될 수 있다. 이를 통해 다양한 환경에서 실행할 수 있는 자바스크립트 코드를 생성할 수 있다.
4. 코드 최적화: 타입스크립트 컴파일러는 콛를 최적화하여 성능을 향상시키고, 불필요한 코드르 제거한다, 이를 통해 생성된 자바스크립트 코드는 더 작고 효율적인 코드가 된다.

> Node.js란 무엇이며, 사용하는 이유는 어떻게 되나요?

- Node.js는 Chrome V8 엔진으로 빌드된 자바스크립트 런타임 환경이다. 즉 Node.js는 웹 브라우저가 아닌 다른 환경에서도 자바스크립트 코드를 실행할 수 있는 환경을 제공한다.

1. 비동기 이벤트 기반: Node.js는 비동기적이고 이벤트 기반의 모델을 사용하여 입출력(I/O)작업을 효율적으로 처리한다. 이를 통해 많은 수의 동시 요청을 처리하고, 높은 성능을 달성할 수 있다.
2. 단일 스레드: Node.js는 단일 스레드 이벤트 루프를 사용하여 동작한다. 이러한 구조는 멀티 스레드 방식에 비해 메모리 사용량이 적고, 더 많은 클라이언트 요청을 처리할 수 있다.
3. 간편한 확장성: 간편하고 유연한 모듈 시스템을 제공하여 쉽게 확장할 수 있다. NPM(Node Package Manager)를 사용하여 다양한 외부 모듈들을 쉽게 서리하고 사용할 수 있다.
4. 높은 생산성: 자바스크립트를 사용하여 전체 스택을 개발할 수 있어 생산성을 향상시키니다. 클라이언트 측과 서버 측에서 동일한 언어를 사용하고 있어 코드의 재사용성이 높아진다.
5. 성능: Chrome V8 엔진을 사용하여 빠른 속도를 제공한다. 또한 비동기 방식의 입출력 작업 처리를 통해 높은 성능을 유지한다.

> Node.js 프로젝트에서 패키지를 관리하는 방법에 대해 설명해주십시오.

- Node Package Manager(NPM)을 사용하는 것이다. Node.js 공식 패키지 관리 도구임.

1. package.json 파일 생성: 프로젝트 루트 디렉토리에 `npm init` 명령으로 package.json 파일을 생성한다. 이 파일은 프로젝트의 메타 데이터 및 의존성 정보를 포함한다.
2. 의존성 추가: 프로젝트에 필요한 패키지를 설치하고 package.json 파일에 의존성을 추가한다. 패키지를 설치할 떄는 `npm install` 명령을 사용한다.
3. 패키지 업데이트: 이미 설치된 패키지의 버전을 업데이트하려면 `npm update` 명령을 사용한다.
4. 패키지 제거: `npm uninstall` 명령을 사용해 패키지를 제거한다.

> 타입스크립트에서 자바스크립트에서 사용할 수 없는 기능 중 어떤 것들이 추가되어 있으며, 이로 인해 어떤 이점이 있나요?

1. 정적 타입 체크: TS는 변수, 함수 및 객체에 대한 명시적인 타입 정의를 제공하여 코드의 안정성을 높인다. 이를 통해 컴파일 시점에서 타입 에러를 발견할 수 있고, 런타임 에러를 사전에 방지할 수 있다.
2. 타입 추론: 타입을 명시적으로 지정하지 않아도 코드를 분석하여 타입을 추론할 수 있따. 이를 통해 코드를 간결하게 작성하고, 잘못된 타입의 변수를 사용하는 실수를 줄일 수 있다.
3. 인터페이스와 타입 별칭: 인터페이스와 타입 별칭을 사용하여 객체의 구조를 정의하고, 코드의 가독성과 재사용성을 높일 수 있다. 이를 톹ㅇ해 코드를 더 직관적으로 작성할 수 있고, 코드의 유지보수성을 향상시킬 수 있다.
4. 제네릭: 제네릭은 코드의 유연성을 높여주는 기능으로, 함수나 클래스에서 사용될 타입을 나중에 지정할 수 있다. 이를 통해 코드의 재사용성을 높이고, 일반적인 알고리즘을 작성할 수 있다.
5. 파이프라인 연산자: TS는 파이프라인 연산자 `|`를 지원하여 함수를 연속적으로 호출하고 결과를 전달할 수 있다. 이를 통해 함수형 프로그래밍 기법을 사용하여 코드를 더 간결하게 작성할 수 있다.
6. 타입 가드: 타입 가드를 사용하여 런타임 시점에서 변수의 타입을 체크할 수 있다. 이를 통해 타입 안정성을 보장하고, 런타임 에러를 방지할 수 있다.

> Node.js에서 발생하는 콜백 지옥에 대해 설명하고, Promise나 async/await을 통해 어떻게 해결할 수 있는지 설명해주세요.

- 콜백 지옥이란, 비동기 코드에서 콜백 함수를 중첩하여 사용할 때 발생하는 코드 가독성이 떨어지고 유지보수가 어려워지는 상황을 의미한다. 특히 Node.js에서 많은 비동기 작업을 처리할 때 발생한다.

해결 방식은 다음과 같다.

1. Promise: Promise는 비동기 작업의 성공 또는 실패와 같은 결과를 나타내는 객체이다. Promise를 사요하면 콜백 함수를 중첩하는 것을 피하고, 비동기 작업을 연결하여 관리할 수 있다. `then()` 및 `catch()` 메서드를 사용하여 비동기 작업의 성공 또는 실패를 처리할 수 있다.
```js
const fs = require('fs');

const readFilePromise = (path) => {
	return new Promise((res, rej) => {
		fs.readFile(path, 'utf8', (err, data) => {
			if (err) {
				reject(err)
			} else {
				resolve(data);
			}
		})
	})
};

readFileProomise('example.txt')
.then((data) => {
	console.log(data);
})
.catch((err) => {
	console.error(err);
});
```

하지만 이 역시도 많이 사용하면 .then() 지옥에 빠지게 된다.

2. async/await: async 함수는 Promise를 반환하는 함수이다. async 함수 내에서 await 키워드를 사용하여 Promise가 처리될 때 까지 기달니 다음 결과를 반환한다. 이를 통해 비동기 키워드를 동기적으로 작성할 수 있으며, 콜백 지옥을 피할 수 있다.
```js
const fs = require('fs');

const readFileAsync = async (path) => {
	try{
		const data = await fs.promises.readFile(path, 'utf8');
		console.log(data)
	} catch (e) {
		console.error(e)
	}
}
```

> NestJS에서 의존성 주입이 어떻게 이루어지며, 이의 장점은 무엇인가요?

> NestJS가 무엇이며, expressJS에 비해 어떤 특징과 장점을 갖고 있는지 설명해보세요.

> Express.js란 무엇인가요?

- Node.js의 백엔드 웹 프레임워크이다. 경량 및 유연한 웹 애플리케이션 개발을 위해 설계되었다.

1. 미들웨어: 미들웨어 기능을 통해 HTTP 요청 및 응답을 처리할 수 있다. 미들웨어는 요청 전달, 응답 생성, 라우팅 및 다른 작업을 수행하는 함수이다. 이를 통해 다양한 기능을 쉽게 추가하고 애플리케이션을 구성할 수 있다.
2. 라우팅: 간단하고 유연한 라우팅 기능을 제공한다. 라우팅을 사용하여 클라이언트 요처에 대한 적절한 핸들러 함수를 매핑할 수 있따. 이를 통해 URL 경로에 따라 요청을 다양한 핸들러로 분배한다.
3. 템플릿 엔진 지원: 다양한 템플릿 엔진을 지원하여 동적인 HTML 콘텐츠를 생성할 수 있다(pug, nunjucks 등)
4. 정적 파일 제공: 정적 파일 제공 기능을 제공하여 이미지, CSS 및 Javacscript 파일과 같은 정적 파일을 쉽게 제공할 수 있다.
5. 세션 및 쿠키 지원: 세션 및 쿠키를 쉽게 관리할 수 있는 기능을 제공한다. 세션을 사용하여 클라이언트의 상태를 유지하고 사용자 인증과 같은 작업을 수행할 수 있다.
6. HTTP 요청 및 응답 제어: HTTP 요청 및 응답을 쉽게 제어할 수 있는 다양한 메서드와 속성을 제공한다. 이를 통해 요청과 응답을 처리하고 원하는 방식으로 조작할 수 있다.(req, res)
   
>Javascript와 Node.js의 차이점을 설명해보세요.

1. Javascript:
	1. 프로그래밍 언어
2. Node.js:
	1. 자바스크립트 코드를 실행하기 위한 런타임 환경

> Node.js 프로젝트에서 패키지를 관리하는 방법으로 npm과 yarn의 차이점은 무엇인가요?

1. 설치속도: yarn은 패키지를 병렬로 설치하여 npm보다 더 빠른 속도를 지원한다
2. 캐싱:yarn은 설치한 패키지를 캐싱하여 동일한 버전의 패키지가 여러 번 설치되는 것을 방지한다. 이를 통해 더 빠른 다운로드와 설치 속도를 제공한다.npm도 지원하고 있지만, yarn이 더 효율적인 캐싱 매커니즘을 가지고 있다.
3. 보안: yarn은 패키지를 다운로드할 때 해당 패키지의 해시를 검증하여 보안성을 높인다. 이를 통해 패키지가 변조되었는지 여부를 확인하여 보안 문제를 방지할 수 있다. 최신 버전의 npm에서도 지원하지만, yarn이 더 강력한 보안을 가지고 있다.
4. 자동 재설치: yarn은 패키지의 종속성이 변경되었을 때 자동으로 필요한 패키지를 다시 설치한다.
5. 명령어: yarn은 설치할 때 `add`를 사용하고, npm은 `install`을 사용하는 등 명령어가 다른 부분이 있다.

현재는 npm도 모두 비슷한 기능을 지원하므로, 명령어의 차이만 있을 뿐 프로젝트의 요구사항과 개발자의 선호도에 따라 둘 중 하나를 선택하면 된다.