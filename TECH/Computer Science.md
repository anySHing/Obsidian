# 면접 대비 질문 리스트

> RESTful API에 대해 설명해주세요.

- 웹에서 자원을 표현하고 상태를 전송하기 위한 하나의 약속이다. HTTP 프로토콜을 사용하여 클라이언트와 서버간의 통신을 가능하게 한다.

1. 자원(Resource): 모든 것이 자원으로 표현된다. ex) 사용자, 게시물, 주문, 등 모든 개체는 자원으로 간주됨
2. 표현(Representation): 자원은 여러 표현으로 표현될 수 있다. 일반저긍로 JSON, XML 또는 HTMl과 같은 형식으로 표현된다. 클라이언트는 요청에 따라 원하는 표현을 선택할 수 있다.
3. 상태(State): 클라이언트와 서버 간의 상호 작용은 상태를 전송한다. 상태는 요청에 대한 응답으로 반환되거나, 클라이언트가 요청을 통해 변경할 수 있다.
4. HTTP Method: RESTful API에서는 HTTP 메서드를 사용하여 자원에 대한 CRUD를 정의한다. 가장 일반적으로 사용되는 메서드는 다음과 같다.
	- GET: 자원을 조회한다.
	- POST: 새로운 자원을 생성한다.
	- PUT: 자원을 업데이트한다.
	- DELETE: 자원을 삭제한다.
5. URI(Uniform Resource Identifier): 각 자원은 고유한 URI를 갖는다. 클라이언트는 URI를 사용하여 특정 자원을 식별하고 요청할 수 있다.
6. 무상태성: RESTful API는 상태를 저장하지 않고, 각 요청을 모든 필요한 정보를 포함한다. 이는 서버 츠겡서 클라이언트의 상태를 관리하지 않으므로 확장성이 용이하다.
7. 캐싱: RESTful API는 HTTP의 캐싱 매커니즘을 활용하여 응답을 캐시할 수 있다. 이는 성능을 향상시키고, 네트워크 부하를 줄일 수 있다.
8. 계층 구조(Layered System): RESTful API는 계층 구조를 가질 수 있다. 클라이언트는 서버와 직접 통신하는 대신 중간 계층을 통해 통신할 수 있다.
	- 예를 들면 API는 server A에 실행, data는 server B에 저장, 요청을 검증하는 것은 server C에서 하는 것을 허용. 클라이언트는 end server에 연결되었는지 매개체에 연결되었는지 알 수 없다.

> 프레임워크와 라이브러리의 차이에 대해서 설명해보세요.

1. 프레임워크
	- 프레임워크는 소프트웨어 개발을 위한 구조와 규칙을 제공하는 추상화된 툴이다.
	- 일반적으로 애플리케이션의 전체 구조를 제어하고, 개발자가 필요한 부분을 채우도록 한다.
	- 프레임워크는 보통 특정한 문제를 해결하기 위한 툴로서, 특정한 개발 패러다임이나 설계 원칙을 따르며, 해당 프레임워크가 제공하는 규칙과 규약을 따라야 한다.
	- Spring, Nest.js, Express.js, Django 등이 있다.
2. 라이브러리
	- 라이브러리는 재사용 가능한 코드 조각으로, 특정한 기능을 수행하기 위한 함수, 클래스, 모듈 등의 집합이다.
	- 개발자가 필요한 기능을 호출하여 사용한다. 개발자는 제어의 흐름을 직접 제어하며, 필요한 라이브러리를 필요한 시점에 가져와 사용할 수 있다.
	- 라이브러리는 보통 특정한 기능을 제공하기 위해 설계되며, 다양한 문제에 대한 해결책으로 사용될 수 있다.

3. 주요한 차이점
	- 제어 흐름:
		- 프레임워크는 개발자에게 제어의 흐름을 제공하며, 개발자는 프레임워크에 따라 코드를 작성한다. -> 프레임워크가 개발자 위에 있다.
		- 라이브러리는 개발자가 직접 제어의 흐름을 조절하며, 필요할 때만 라이브러리를 호출하여 사용한다.
	- 의존성:
		- 프레임워크는 개발자가 프레임워크의 규칙과 규약을 따라야 하므로, 개발자는 프레임워크에 의존하게 된다.
		- 라이브러리는 개발자가 필요할 때만 호출하여 사용하므로, 개발자는 라이브러리에 의존하지 않고도 개발을 진행할 수 있다.
	- 확장성:
		- 프레임워크는 제공하는 규칙과 규약을 따르는 선에서 확장이 가능하다.
		- 라이브러리는 개발자가 필요한 시점에 호출하여 사용하기 때문에, 개발자에게 달려있다.

> GET과 POST의 차이는 무엇인가요?

1. 용도: 
	- GET: 리소스를 요청하기 위해 사용한다. 주로 데이터를 서버로 보내지 않고 서버로부터 데이터를 가져오기 위해 사용한다.
	- POST: 리소스를 생성하거나 업데이트하기 위해 사용한다.
2. 데이터 전송 방식:
	- GET: 데이터는 URL의 쿼리 스트링에 포함되어 전송된다. 데이터는 주소 표시줄에 노출되며, 길이에 제한이 있다.
	- POST: 데이터는 HTTP 요청의 바디에 포함되어 전송된다. 데이터는 사용자에게 노출되지 않으며, 길이에 제한이 없다.
3. 캐싱:
	- GET: 응답은 캐시될 수 있다. 동일한 요청이 다시 발생할 때 이전에 받은 응답을 재사용할 수 있따.
	- POST: 응답은 캐시되지 않는다. POST 요청은 일반적으로 상태를 변경하므로 캐싱이 적용되지 않음
4. 안전성:
	- GET: 요청이 브라우저의 주소 표시줄에 노출되므로 민감한 데이터(비밀번호 등)를 전송하는데 적합하지 않다.
	- POST: 요청의 데이터는 바디에 포함되어 있으므로 GET보다 안전하다. 민감한 데이터를 전송하는데 적합하다.
5. 멱등성:
	- GET: 동일한 요청을 여러 번 보내더라도 서버의 상태에 변화를 일으키지 않는다.(== 멱등성이다)
	- POST: 동일한 요청을 여러 번 보내면 서버의 상태가 변경될 수도 있다.

> 객체지향 프로그래밍이란 무엇인가요?

- 현실 세계의 개념을 모델링하고 이를 소프트웨어 객체로 표현하여 문제를 해결하는 방법론이다. 이러한 객체는 데이터와 행위(메서드)를 함께 묶어서 캡슐화하고, 객체 간에 상호작용하며 프로그램을 구성한다.
- 주요 개념과 특징
	1. 클래스와 객체:
		- 클래스는 객체의 설계도라고 볼 수 있으며, 객체는 클래스의 인스턴스이다.
		- 클래스는 속성(데이터)와 메서드(행위)로 ㄱ성된다.
		- ex) Car Class는 model과 color field를 가지고 있으며, drive(), stop() method를 가지고 있다.
	2. 캡슐화:
		- 데이터와 그 데이터를 처리하는 메서드를 하나로 묶는 것을 말한다.
		- 클래스는 데이터를 숨기고 외부에서 직접 접근할 수 없도록 보호한다. 대신 메서드를 통해 데이터에 접근하고 조작한다.
	3. 상속:
		- 하나의 클래스가 다른 클래스의 특성(속성과 메서드)을 이어받는 것을 말한다.
		- 상속을 통해 코드의 재사용성을 높이고 계층적인 관계를 형성할 수 있다.
	4. 다형성:
		- 같은 메서드 이름을 사용하면서 각각의 객체에 따라 다르게 동작하도록 하는 개념이다.
		- 오버로딩, 오버라이딩을 통해 구현된다.
	5. 추상화:
		- 객체에서 중요한 특성을 강조하고 세부 사항을 숨기는 것을 말한다.
		- 즉, 객체의 공통된 특성을 추출하고 클래스로 정의하고, 다른 세부적인 부분은 숨기는 것을 의미한다.

> HTTP Method에 대해서 설명해보세요.

1. GET
	- 서버에서 특정 리소스의 표현을 요청한다.
	- 주로 데이터를 가져오는 데 사용된다.(Read Only)
	- 요청된 데이터는 URL의 쿼리 스트링에 포함될 수 있다.
2. POST:
	- 서버에 새로운 리소스를 생성하거나 데이터를 제출한다.
	- 주로 데이터를 전송하여 서버의 상태를 변경하거나 업데이트하는 데 사용된다(Write)
3. PUT:
	- 서버에 존재하는 리소스를 업데이트한다.
	- 전체 리소스를 교체한다. 즉, 클라이언트가 지정한 리소스로 대체된다.
4. PATCH:
	- 서버에 존재하는 리소스의 일부를 업데이트한다.
	- 일부만 변경하고 나머지는 그대로 유지한다.
5. DELETE:
	- 서버에서 특정 리소스를 삭제한다.
	- 해당 리소스를 삭제하고 응답은 삭제 결과를 나타낸다.
6. HEAD:
	- GET 요청과 동일하지만, 응답에서 본문(body)을 제외하고 헤더 정보만을 반환한다.
	- 주로 헤더 정보를 가져와 리소스의 메타 데이터를 확인하는 데 사용된다.
7. OPTIONS:
	- 서버에서 지원되는 HTTP 메서드를 확인하거나 리소스에 대한 지원되는 메서드 옵션을 요청한다.
	- CORS(Cross-Origin Resource Sharing) 요청 시 브라우저에서 자동으로 OPTIONS 요청을 전송한다.
8. TRACE:
	- 클라이언트에서 서버까지의 경로를 따라 메시지 루프백을 요청한다.
	- 주로 디버깅 및 진단 목적으로 사용된다.
9. CONNECT:
	- 목적지 서버로의 프록시 연결을 설정한다.
	- 주로 SSL/TLS와 함께 사용되어 안전한 터널을 설정하는 데 사용된다.

> HTTP 상태 코드에 대해 설명해보세요.

- 클라이언트가 보낸 요청에 대한 서버의 응답을 나타내는 세 자리 숫자로 이루어진 콛이다. 이 코드는 요청이 성공했는지, 실패했는지, 그 이유가 무엇인지 등을 나타낸다. HTTP Status Code는 다양한 범주에 속하며, 각각의 범주는 특정한 의미와 응답 형식을 가진다.

1. 1xx(Informational, 정보)
	- 요청이 수신되었고 처리가 진행 중인 상태를 나타낸다.
2. 2xx(Success, 성공)
	- 요청이 성공적으로 처리되었음을 나타낸다.
	- 가장 많이 사용되는 코드는 200(ok)
3. 3xx(Redirection, 리다이렉션)
	- 요청을 완료하기 위해 추가 동작이 필요함을 나타낸다.
	- ex)리소스가 새 위치로 이동되었음을 나타내는 301(Moved Permanently)
4. 4xx(Client Error, 클라이언트 오류)
	- 클라이언트 측에서 발생한 오류를 나타낸다.
	- ex) 잘못된 요청을 나타내는 400(Bad Request)
5. 5xx(Server Error, 서버 오류)
	- 서버 측에서 발생한 오류를 나타낸다.
	- ex) 서버에서 처리할 수 없는 요청이 도착했음을 나타내는 500(Internal Server Error)

> 프로세스와 스레드의 차이에 대해 설명해보세요.

1. 정의:
	- 프로세스: 운영 체제에서 실행 중인 프로그램을 의미한다. 각 프로세스는 독립적인 메모리 공간을 가지며, 운영 체제는 각 프로세스에게 자원을 할당한다.
	- 스레드: 프로세스 내에서 실행되는 실행 단위를 의미한다. 한 프로세스 내에서 여러 개의 스레드가 동시에 실행될 수 있으며, 스레드는 해당 프로세스의 메모리 공간을 공유한다.
2. 자원 공유:
	- 프로세스: 각 프로세스는 독립적이 메모리 공간을 가지므로, 프로세스 간의 자원 공유는 별도의 매커니즘이 필요하다. 일반적으로 프로세스 간의 통신(IPC)를 사용하여 데이터를 교환한다.
	- 스레드: 한 프로세스 내의 스레드는 같은 메모리 공간을 공유하기 때문에, 스레드 간의 자원 공유가 더 간단하다. 이로 인해 스레드 간의 통신이 더욱 효율적으로 이루어짐
3. 생성 비용:
	- 프로세스: 프로세스를 생성하는 데는 상당한 시스템 리소스가 필요하므로, 프로세스 생성에는 상대적으로 높은 비용이 든다.
	- 스레드: 스레드는 프로세스 내에서 생성되므로 프로세스 생성보다 훨씬 적은 시스템 리소스가 필요하다. 따라서 스레드의 생성 비용은 상대적으로 낮다.
4. 병행성:
	- 프로세스: 각 프로세스는 독립적으로 실행되므로, 프로세스 간의 병행성을 달성하기 위해서는 별도의 매커니즘이 필요하다.
	- 스레드: 한 프로세스 내의 스레드는 공유된 메모리 공간을 가지므로, 스레드 간의 병행성을 달성하기가 더욱 쉽다.
5. 동기화:
	- 프로세스: 프로세스 간의 동기화는 별도의 IPC(Inter-Process Communication) 매커니즘이 필요하다.
	- 스레드: 스레드 간의 동기화는 프로세스 내에서 공유된 자원을 직접 접근할 수 있으므로, 동기화가 간단하다.

> RDBMS와 NoSQL의 차이에 대해 설명해보세요.

1. 데이터 모델:
	- RDBMS: 관계형 데이터 모델을 사용한다. 데이터는 테이블의 형태로 구성되며, 각 테이블은 행과 열의 조합으로 이루어진다. 테이블 간의 관계는 외래 키를 사용하여 정의한다.
	- NoSQL: 다양한 데이터 모델을 사용할 수 있다. 주로 문서(document), 키-값(key-value), 그래프(graph), 와이드 컬럼(wide-column)등의 모델을 사용한다.
2. 스키마:
	- RDBMS: 정적인 스키마(static schema)를 사용한다. 데이터의 구조는 미리 정의되고 변경하기 어렵다.
	- NoSQL: 동적인 스키마(dynamic schema)를 사용한다. 데이터 구조는 유연하며, 필요에 따라 동적으로 변경할 수 있다.
3. 확장성:
	- RDBMS: 수직적 확장(vertical scaling)을 사용하여 서버의 성능을 향상시킨다. 단일 서버의 성능을 높임
	- NoSQL:수평적 확장(horizontal scaling)을 사용하여 시스템의 성능을 향상시킨다. 여러 대의 서버를 추가하여 시스템을 확장시킴
4. 트랜잭션 처리:
	- RDBMS: ACID(Atomicity, Consistency, Isolation, Durability) 트랜잭션을 지원한다. 데이터 일관성과 안정성을 보장하기 위해 트랜잭션 처리가 중요하다.
	- NoSQL: 일부 NoSQL 데이터베이스는 ACID 트랜잭션을 제공하지만, 다수의 NoSQL 시스템은 유연성과 확장성을 위해 일관성 모델을 제한하거나 제공하지 않을 수 있다.
5. 용도: 
	- RDBMS:복잡한 쿼리와 데이터 분석을 위해 사용된다. 전통적인 엔터프라이즈 애플리케이션에서 널리 사용된다.
	- NoSQL: 대용량의 비정형 데이터를 처리하거나 실시간 처리, 웹 및 모바일 애플리케이션에서 사용된다. Big Data 및 IoT(Internet of Things)와 같은 빠르게 성장하는 데이터 요구 사항에 대응할 수 있다.
- 요약
	- RDBMS: 데이터 일관성과 안정성을 중시하는 전통적인 데이터베이스 시스템
	- NoSQL: 유연성과 확장성을 강조하는 새로운 유형의 데이터베이스 시스템

> CORS(Cross-Origin Resource Sharing)에 대해 설명해보세요.

- 웹 애플리케이션에서 다른 출처로부터 리소스를 요청할 때 발생하는 보안 정책을 우회하는 매커니즘이다. 웹 애플리케이션은 보안상의 이유로 동일 출처 정책(Same-Origin Policy)에 따라 다른 출처로부터 온 리소스에 접근할 수 없는데, CORS는 이 정책을 유연하게 해제하여 다른 출처의 리소스에 접근할 수 있도록 한다.

- 다음과 같은 상황에서 사용한다.
	1. AJAX 요청: 웹 애플리케이션에서 XMLHttpRequest나 Fetch API 등을 사용하여 다른 출처의 데이터를 요청할 때
	2. Web Fonts, Stylesheets, Scripts, Images 등의 리소스 요청: 웹 페이지에서 다른 출처의 리소스를 가져와 사용할 때
	3. API 호출: 웹 애플리케이션의 RESTful API등의 서비스로부터 데이터를 가져올 때

- CORS는 다음과 같은 단계로 작동한다.
	1. 요청 전송: 클라이언트에서 다른 출처로 요청을 보낸다.
	2. 옵션(pre-flight) 요청: 일부 요청은 브라우저에서 사전 요청(pre-flight)을 보낸다. 이는 실제 요청 전에 서버가 허용하는 메서드 및 헤더를 확인하기 위함이다.
	3. 응답: 서버는 요청을 처리하고, 요청에 대한 응답을 보낸다. 응답에는 CORS 정책에 대한 정보가 포함된다.
	4. 자원 전송: 클라이언트가 서버의 응답을 받고, 필요한 경우 요청한 리소스를 처리한다.

- Access-Control-Allow-Origin: 서버에서 클라이언트로 온 요청을 허용하는 출처를 나타낸다.
- Access-Control-Allow-Methods: 서버에서 허용되는 HTTP 메서드를 나타낸다.

> OAuth 2.0의 흐름에 대해 설명해보세요.

- OAuth 2.0은 클라이언트 애플리케이션이 사용자의 인증 정보를 안전하게 관리하고, 제3자 서비스의 리소스에 접근할 수 있도록 하는 프로토콜이다.
-  대략적 흐름
	1. 애플리케이션 등록: 클라이언트 애플리케이션은 인증 서버에 등록된다. 이 과정에서 클라이언트 아이디와 클라이언트 시크릿이 발급된다.
	2. 인가 코드 요청: 클라이언트 애플리케이션은 사용자를 인증 서버로 리디렉션한다. 이 때 클라이언트 아이디와 요청하는 스코프(권한)을 함께 전달한다.
	3. 사용자 로그인: 사용자는 인증 서버에 로그인하고, 요청도니 스코프에 대한 권한을 부여할지 여부를 결정한다.
	4. 인가 코드 발급: 사용자가 권한을 부여하면, 인증 서버는 클라이언트 애플리케이션에게 인가 코드를 발급한다.
	5. 액세스 토큰 요청: 클라이언트 애플리케이션은 인가 코드를 사용하여 인증 서버에 액세스 토큰을 요청한다.
	6. 액세스 토큰 발급: 인증 서버는 클라이언트 애플리케이션에게 액세스 토큰을 발급한다.
	7. 리소스 서버 저근: 클아이너트 애플리케이션은 발급받은 액세스 토큰을 사용하여 제3자 리소스 서버에 접근하고, 요청한 리소스를 받아온다

> 마이크로 서비스와 모놀리틱 서비스의 차이를 설명해보세요.

1. 모놀리틱 서비스:
	- 전통적인 단일 애플리케이션으로, 하나의 코드 베이스와 단일 실행 파일로 구성된다.
	- 모든 서비스 컴포넌트는 같은 코드 베이스에 포함되어 있으며, 하나의 데이터베이스에 의해 관리된다.
	- 애플리케이션을 변경하거나 배포할 때 전체 애플리케이션을 다시 빌드하고 배포해야 한다.
	- 개발, 테스트, 배포가 단순하고 관리가 용이하다.
	- 사이즈가 커지면 확장성과 유연성이 제한된다.
2. 마이크로 서비스:
	- 애플리케이션을 작은, 독립적인 서비스로 분해한다. 각 서비스는 자체적으로 독립적으로 배포할 수 있다.
	- 각 마이크로 서비스는 고유한 코드 베이스와 데이터베이스를 가지며, 특정 비즈니스 기능이나 기술적 책임을 담당한다.
	- 서비스 간 통신은 네트워크를 통해 이루어지며, 주로 API를 통해 이루어진다.
	- 애플리케이션을 변경할 때 필요한 서비스만 다시 빌드하고 배포할 수 있으므로 배포가 더욱 빠르고 유연하다.
	- 개발 팀 간 독립성이 높아져, 각 팀은 자유롭게 선택한 기술 스택과 개발 방법론을 사용할 수 있다.
	- 분산 시스템이므로 관리가 복잡할 수 있다.

> 세션과 쿠키의 차이를 설명해보세요.

1. 저장 위치:
	- 쿠키: 클라이언트 측에 저장된다. 쿠키는 클라이언트의 웹 브라우저에 텍스트 형태로 저장된다.
	- 세션: 서버 측에 저장된다. 세션은 서버 메모리가 데이터베이스에 저장된다.
2. 용도:
	- 쿠키: 주로 클라이언트의 상태를 유지하기 위해 사용한다. 예를 들어 사용자의 로그인 상태를 유지하거나 사용자의 선호 설정을 저장하는 데에 사용한다.
	- 세션: 클라이언트의 상태를 서버에 유지하기 위해 사용한다. 주로 사용자의 인증 상태를 관리하거나 사용자의 상태를 추적하는 데 사용한다.
3. 보안:
	- 쿠키: 클라이언트 측에 저장되므로 보안에 취약할 수 있다. 민감한 정보를 저장할 때 문제가 발생할 수 있음
	- 세션: 서버 측에 저장되므로 상대적으로 안전하다. 민감한 정보를 서버에 저장하고 처리하기 때문에 보안성이 높음
4. 수명:
	- 쿠키: 설정된 만료 날짜나 기간에 따라 지정된 시간 동안 유지된다. 만료 날짜가 설정되지 않으면 브라우저가 닫힐 때 까지 유지된다.
	- 세션: 사용자가 브라우저를 닫거나 로그아웃할 때 까지 유지된다. 일반적으로 세션은 일정 시간 동안 유지되고, 세션 유효 시간이 지나면 만료된다.
5. 용량 제한:
	- 쿠키: 도메인당 쿠키의 수 및 쿠키의 크기에 제한이 있다. 일반적으로 한 도메인에는 최대 몇 개의 쿠키를 가질 수 있으며, 각 쿠키는 일정한 크기를 초과할 수 없다.
	- 세션: 서버 측에 저장되므로 일반적으로 용량 제한이 없다. 그러나 서버 메모리나 데이터베이스의 용량에 따라 제한될 수 있다.

> CI/CD란 무엇인지 설명해보세요.

-  소프트웨어 개발 및 배포 프로세스의 자동활르 위한 개념이다. 'Conitinuous Integration(지속적 통합)'과 'Continuous Deployment(지속적 배포) | Continuous Delivery(지속적 제공)'의 약자이다. 이 두 가지 개념은 함께 사용되어 개발자 및 팀이 소프트웨어를 효율적으로 빠르게 빌드, 테스트, 배포할 수 있도록 지원한다.

1. CI:
	- 개발자가 코드를 공유 레포지토리에 push할 때 마다 자동으로 코드의 통합, 빌드, 테스트를 수행하는 개발 방법론
	- 여러 개발자가 동시에 작업하는 경우 코드 충돌을 방지하고, 통합된 코드가 신속하게 테스트되어 품질을 유지할 수 있다.
	- 주로 자동화된 빌드 및 테스트 파이프라인을 통해 구현된다.
2. CD:
	1. Continuous Delivery(지속적 제공):
		- 소프트웨어를 빌드 및 테스트한 후에 자동으로 프로덕션 환경으로 제공할 수 있는 프로세스이다.
		- Continuous Delivery를 통해 개발된 소프트웨어는 언제든지 프로덕션 환경에 배포할 수 있또록 준비된다. 그러나 실제 배포는 수동으로 이루어질 수도 있다.
		- 소프트웨어의 배포 과정을 자동화하고, 배포 시간을 단축하며, 신속한 피드백을 통해 빠른 개선을 가능하게 한다.
	2. Continuous Deploy(지속적 배포):
		- Continuous Delivery의 한 형태로, 모든 변경 사항이 프로덕션 환경으로 자동으로 배포되는 것을 의미한다.
		- CD의 가장 극단적인 형태로, 테스트를 통과한 모든 코드가 즉시 프로덕션 환경에 배포되어 사용자에게 실시간으로 제공된다.
		- 릴리스 주기를 단축하고, 빠른 사용자 피드백을 통해 소프트웨어의 품질을 높일 수 있다.

> Call By Value와 Call By Reference의 차이에 대해 설명해보세요.

- 둘은 모두 함수 호출 시 인수를 전달하는 방식을 나타내는 용어이다. 차이는 매개 변수를 전달하는 방식에서 차이가 있다.

1. Call By Value(값에 의한 호출):
	- 함수에 매개 변수를 전달할 때, 해당 매개 변수의 값이 복사되어 전달된다.
	- 따라서 함수 내에서 매개 변수의 값이 변경되어도 호출된 곳의 변수 값은 변경되지 않는다.
	- Call By Value 방식은 주로 기본 데이터 타입(정수, 실수, 문자열 등)을 전달할 때 사용된다.
```ts
const changeValue = (x: number) => {
	x = 10;
}
const value = 5;

changeValue(value);

console.log(value); // 5 (변수의 값은 변경되지 않음)
```

2. Call By Reference(참조에 의한 호출):
	- 함수에 매개 변수를 전달할 때, 해당 매개 변수의 메모리 주소(참조)가 전달된다.
	- 따라서 함수 내에서 매개 변수의 값을 변경하면 호출된 곳의 변수 값도 변경된다.
	- 객체나 배열과 같은 참조 타입을 전달할 때 사용된다.
```ts
const changeList = (list: any[]) => {
	list.push(4);
}

const anyList = [1, 2, 3];
changeList(anyList);

console.log(anyList); // [1, 2, 3, 4];
```

> 클로져(Closure)에 대해 설명해보세요.

> MVC 아키텍쳐에 대해 설명해보세요.

- Model - View - Controller의 약자로, 소프트웨어를 설계하고 구현하는 데 사용되는 소프트웨어 아키텍쳐 패턴이다. 응용 프로그램을 세 가지 주요 구성 요소로 분리하여 개발하는 방법론이다.

1. Model(모델):
	- 모델은 애플리케이션의 데이터와 비즈니스 로직을 나타낸다.
	- 데이터베이스에서 데이터를 읽고 쓰는 등의 데이터 조작 작업을 수행하거나, 데이터의 유효성을 검사하고 데이터를 처리하는 등의 비즈니스 로직을 담당한다.
	- 주로 독립적으로 구현되며, 데이터의 변경에 따라 알림을 보내는 옵저버 패턴을 통해 뷰와 컨트롤러에 통지한다.
2. View(뷰):
	- 뷰는 사용자에게 데이터를 시각적으로 표시하는 부분을 나타낸다.
	- UI 요소를 생성하고, 모델에서 데이터를 검색하여 화면에 표시한다.
	- 주로 사용자와의 상호 작용에 응답하고, 사용자 입력을 처리하여 컨트롤러에 전달한다.
3. Controller(컨트롤러): 
	- 컨트롤러는 모델과 뷰 간의 상호작용을 조정하고 제어한다.
	- 사용자 입력을 받아 모델에 데이터를 전달하거나, 모델로부터 데이터를 가져와 뷰에 전달한다.
	- 주로 비즈니스 로직을 포함하지 ㅇ낳으며, 사용자의 요청을 분석하여 적절한 처리를 수행하고 결과를 뷰에 전달한다.

> RESTful API와 GraphQL의 차이는 무엇인가요?

- RESTful API와 GraphQL은 모두 웹 API를 설계하고 구현하는 데 사용되는 기술이다.

1. 데이터 요청 방식:
	- RESTful API: 리소스 단위로 데이터를 요청하고 반환한다. 각 엔드 포인트는 특정 리소스의 집합을 나타내며, 요청에 따라 해당 리소스에 대한 작업을 수행한다.
	- GraphQL: 클라이언트가 필요한 데이터를 쿼리하는 방식으로 동작한다. 클라이언트는 원하는 필드와 관계를 포함하는 쿼리를 작성하고 서버는 해당 쿼리에 대한 결과를 반환한다.
2. 데이터 반환 형식:
	- RESTful API: JSON, XML 등과 같은 표준 데이터 형식을 사용하여 데이터를 반환한다. 클라이언트는 서버가 제공하는 엔드 포인트에 요청을 보내고 반환된 데이터를 처리한다.
	- GraphQL: 클라이언트가 요청한대로 정확한 데이터를 반환한다. 클라이언트는 필요한 필드 및 관계만 요청하고, 서버는 해당 요청에 맞게 데이털르 구성하여 반환한다.
3. 오버헤드:
	- RESTful API: 서버에서 제공하는 각 엔드포인트에 대해 별도의 요청을 보내야 한다. 따라서 클라이언트가 여러 개의 엔드 퐁니트에서 데이털르 가져와야 하는 경우 요청 오버헤드가 발생할 수 있다.
	- GraphQL: 클라이언트가 요청한 필드 및 관계에 대해 단일 요청을 보내고 서버는 해당 요청에 대한 데이터를 한번에 반환한다. 이로 인해 네트워크 오버헤드가 감소하고 데이터 효율성이 높아진다.
4. 캐싱:
	- RESTful API: HTTP 캐시를 활용하여 데이터를 캐싱할 수 있다. 클라이언트가 동일한 엔드 포인트에 대해 여러 번 요청할 경우 캐시된 데이터를 반환시킬 수 있다.
	- GraphQL: 일반적으로 HTTP 캐싱을 지원하지 않는다. 각 쿼리는 고유한 URl이 아니기 때문에 클라이언트가 요청한 쿼리와 일치하는 캐시를 찾기 어렵다.

> JWT(JSON Web Token)에 대해 설명해주세요.

- 웹 표준은 RFC 7519에 정의된 액세스 토큰의 한 형식이다. 이는 사용자가 인증되고 인가된 후에 서버와 클라이언트 간에 정보를 안전하게 전송하기 위한 방법을 제공한다. 주로 웹 애플리케이션과 API 간의 인증 및 권한 부여에 사용된다.

1. Header(헤더):
	- JWT의 유형 및 해시 알고리즘 등의 메타 데이터를 포함한다. 일반적으로 'alg(알고리즘)'과 'typ(토큰 유형)'의 두 가지 속성을 퐇마한다.
2. Payload(페이로드):
	- 실제로 전송되는 데이터가 포함된다. 클레임(claim)이라고도 불리는 이 부분에는 토큰의 주장(claim)들이 포함된다. 주로 클라이언트의 식별 정보나 추가적인 메타 데이터를 포함한다.
3. Signature(서명):
	- 헤더와 페이로드의 내용을 사용하여 서명이 생성된다. 서명은 토큰이 변경되지 않았음을 확인하고, 발신자가 신원을 입증한다. 이를 위해 서버는 비밀 키를 사용하여 서명을 생성하고, 클라이언트는 토큰을 수신한 후에 서버에서 발급한 키를 사용하여 서명을 확인한다.

- JWT는 토큰 자체에 필요한 모든 정보를 포함하고 있으므로 서버의 데이터베이스에 토큰을 저장할 필요가 없다. 이는 분산된 서비스나 마이크로서비스 아키텍쳐에서 유용하며, 특히 사용자가 다양한 서비스를 이용하는 경우에 유용하다.
- 그러나 JWT는 클라이언트에게 정보를 제공하기 때문에, 중요한 정보를 토큰에 포함하지 않는 것이 중요하다. 민감한 정보는 토큰 대신 서버의 세션에 저장되어야 한다. 또한 토큰의 유효 기간(만료 기간)을 설정하여 보안을 강화할 수 있다.

> 컴파일러와 인터프리터의 차이는 무엇인가요?

- 컴파일러와 인터프리터 모두 프로그래밍 언어를 기계어로 변환하여 실행하는데에 사용되는 도구이다.

1. 변환 시기:
	- 컴파일러: 소스 코드를 전체적으로 컴파일하여 중간 코드 또는 기계어로 변환한다. 변환된 코드는 나중에 실행되며, 변환 후에는 원본 코드를 실행하지 않는다.
	- 인터프리터: 소스 코드를 한 줄씩 읽고, 각 줄을 즉시 실행한다. 따라서 소스 코드가 실행될 때 바로 변환되며, 실행 중에 변환된 코들르 실행한다.
2. 실행 방식:
	- 컴파일러: 전체 소스 코드를 한번에 변환하고, 이후에 변환된 코드를 실행한다. 변환된 코드는 일반적으로 실행 속도가 빠르다.
	- 인터프리터: 소스 코드를 한 줄씩 읽어 실행하므로, 변환 및 실행 과정이 동시에 이루어진다. 이로 인해 실행 속도가 느릴 수 있다.
3. 오류 발견:
	- 컴파일러: 소스 코드를 컴파일하는 동안 오류를 발ㄹ견하며, 오류가 발견되면 변환을 중지하고 오류 메시지를 출력한다.
	- 인터프리터: 소스 코들르 실행하는 동안 오류를 발견하며, 오류가 발견되면 해당 줄에서 실행을 중지하고 오류 메시지를 출력한다.
4. 사용 방식:
	- 컴파일러: 대부분의 경우 컴파일러는 소스 코드를 컴파일하여 실행 파일을 생성하고, 이후에 실행 파일을 실행한다. 이러한 방식은 반복적인 실행에는 유리하지 않을 수 있다.
	- 인터프리터: 소스 코드를 직접 실행하기 때문에, 코드를 수정하고 즉시 실행하는데 유용하다.

- 일반적으로 컴파일러는 실행 속도가 빠르지만 컴파일 시간이 오래 걸리고, 실행 파일이 생성되어야 하므로 수정이 발생하면 다시 컴파일해야 한다.
- 인터프리터는 실행 속도가 느리지만 수정이 발생하면 즉시 실행할 수 있어 개발 및 디버깅에 편리하다.

> 동기식과 비동기식 프로그래밍의 차이를 설명해보세요.

1. 동기식 프로그래밍: 
	- 코드가 순차적으로 실행되는 방식을 의미한다
	- 한 작업이 완료될 때 까지 다음 작업을 기다리며, 작업이 순차적으로 실해된다.
	- 코드가 순차적으로 실행되므로 결과가 순서대로 반환되어 예측하기 쉽다.
2. 비동기식 프로그래밍
	- 코드가 순차적으로 실행되지 않고, 작업이 병렬로 실행되는 방식을 의미한다.
	- 한 작업이 완료될 때 까지 기다리지 않고 다음 작업을 실행한다.
	- 비동기적 작업이 완료되면 콜백 함수를 사용하여 결과를 처리한다.

- 동기식 프로그래밍은 코드의 흐름이 단순하고 예측하기 쉽지만, 비동기식 프로그래밍은 병렬로 여러 작업을 실행할 수 있으므로 시간을 효율적으로 활용할 수 있다.
- 특히 네트워크 요청, 파일 읽기/쓰기, 데이터베이스 조회 등의 I/O 작업을 처리할 때 비동기식 프로그래밍이 유용하다. 그러나 비동기식 콛느느 동기식 코드보다 복잡할 수 있으며, 콜백 지옥이 발생할 수 있다. 최신 언어 및 런타임 환경에서는 Promise, async/await과 같은 도구를 사용하여 비동기 코드를 보다 깔끔하게 작성할 수 있도록 지원한다.

> 컨테이너와 가상머신의 차이는 무엇인가요?

- 컨테이너와 가상머신은 모두 소프트웨어를 격리된 환경에서 실행할 수 있게 해주는 기술이지만, 실행 방식과 격리 수준에서 차이가 있다.
  
1. 가상머신:
	- 호스트 운영 체제 위에서 작동하는 완전한 가상화 환경을 제공한다.
	- 하이퍼바이저(Hypervisor)를 통해 하드웨어 리소스를 가상화하고, 호스트 시스템과 완전히 분리된 환경에서 실행된다.
	- 일반적으로 무겁고 느리며, 가상화 오버헤드가 발생할 수 있다.
2. 컨테이너:
	- 호스트 운영 체제의 리소스를 공유하면서 격리된 환경에서 프로세스를 실행하는 가벼운 가상화 기술이다.
	- 호스트 운영 체제의 커널을 공유하므로, 가상 머신에 비해 실행 오버헤드가 적다.
	- 각 컨테이너는 애플리케이션, 런타임, 시스템 도구 및 라이브러리를 포함하는 격리된 파일 시스템 레이어를 가진다.
	- 컨테이너는 가상머신보다 빠르며, 더 적은 리소스를 소비하며, 빠르게 시작될 수 있다.

> 소프트웨어의 생명 주기에 대해 설명해주세요.

- 소프트웨어를 개발하고 유지보수하는 과정을 단계별로 관리하는 방법론이다.

1. 요구 분석:
	- 사용자의 요구사항을 수집, 분석하고 문서화하는 단계
	- 시스템이나 소프트웨어의 기능, 성능, 인터페이스, 제약 사항 등을 결정한다.
2. 설계:
	- 요구사항을 바탕으로 시스템의 구조와 기능을 설계하는 단계
	- 소프트웨어의 아키텍쳐, 데이터 구조, 인터페이스, 알고리즘 등을 결정한다.
3. 구현:
	- 설계된 시스템을 실제로 코딩하는 단계
	- 프로그래밍 언어와 개발 도구를 사용하여 코드를 작성하고, 모듈을 통합하여 시스템을 개발한다.
4. 테스트:
	- 개발된 소프트웨어를 테스트하여 오류를 찾고 품질을 확인하는 단계
	- 단위 테스트, 통합 테스트, 시스템 테스트 등의 다양한 테스트 수준이 포함될 수 있다.
5. 배포:
   - 테스트를 완료한 소프트웨어를 실제 운영 환경으로 배포하는 단계
   - 사용자에게 소프트웨어를 제공하고, 운영 및 유지 보수를 위한 환경을 설정한다.
6. 유지보수:
   - 배포된 소프트웨어를 지속적으로 관리하고 보완하는 단계
   - 사용자 피드백을 수집하고, 오류를 수정하며 새로운 요구사항을 반영하여 소프트웨어를 개선한다.

> 디자인 패턴이 무엇이고 어떻게 유용한가요?

- 디자인 패턴은 소프트웨어 개발에서 자주 발생하는 문제를 해결하기 위한 재사용 가능한 해결책이다. 이러한 패턴들은 공식적인 설계 방법이 아니라, 다양한 상황에서의 최선의 실천 방법이나 템플릿이다. 각 패턴은 특정한 문제를 해결하기 위해 검증된 해결책을 제시하고, 이를 통해 소프트웨어를 보다 효율적으로 디자인하고 구현할 수 있도록 돕는다.
  
- 디자인 패턴은 크게 세가지 유형으로 나뉜다.
	1. 생성 패턴: 객체 생성 매커니즘을 추상화하여 객체를 생성하고 초기화하는 방법을 결정한다. 대표적인 예로는 싱글톤, 팩토리, 빌더 패턴 등이 있다.
	2. 구조 패턴: 클래스나 객체를 조하하여 더 큰 구조를 만드는 방법을 다룬다. 대표적으로 어댑터, 데코레이터, 컴포지트 패턴 등이 있다.
	3. 행위 패턴: 객체나 클래스 간의 알고리즘과 책임을 분산하는 방법을 다룬다. 대표적으로 옵저버, 스트래티지, 커맨드 패턴 등이 있다.

- 디자인 패턴이 유용한 이유
	- 재사용성: 검증된 솔루션이므로, 이를 재사용하여 소프트웨어를 보다 쉽게 디자인하고 개발할 수 있다.
	- 유지보수성: 패턴을 사용하면 소프트웨어의 코드가 더 읽기 쉽고 유지보수가 쉬워진다. 각 패턴은 특정한 의도와 목적을 가지고 있기 때문에, 코드의 의도를 더 명확하게 전달할 수 있다.
	- 확장성: 소프트웨어를 보다 쉽게 확장할 수 있다. 패턴을 통해 변경에 대한 영향을 줄이고, 시스템의 유연성을 높일 수 있다.

- 그러나 모든 문제에 대해 디자인 패턴을 적용하는 것을 좋지 않을 수 있다. 패턴을 오용하거나 과도하게 사용하면 코드의 복잡성이 증가하고 이해하기 어려워질 수 있으므로 적절한 패턴을 선택하고 적용하는 것이 중요하다.

> DB에서 인덱스를 잘 사용하면 어떤 장점이 있나요?

1. 데이터 검색 속도 향상: DB가 특정 열(컬럼)에 대해 빠르게 검색할 수 있다. 인덱스는 정렬된 데이터 구조로 구현되어 있기 때문에 이를 통해 검색 시간이 크게 줄어든다.
2. 쿼리 성능 향상: SELECT 쿼리의 실행 속도가 향상된다. 특히 WHERE 절에 인덱스된 열을 사용하는 경우, DB는 인덱스를 활용하여 필요한 데이터를 빠르게 찾을 수 있다.
3. 정렬 및 그룹화 효율성 향상: ORDER BY 및 GROUP BY와 같은 정렬 및 그룹화 작업에서 인덱스를 사용하면 처리 속도가 향상된다.
4. 고유성 보장: 유니크 인덱스를 사용하면 특정 열에 대해 고유성을 보장할 수 있다. 이를 통해 중복된 데이터를 방지하고 데이터 무결성을 유지할 수 있다.
5. 조인 성능 향상: 인덱스를 사용하여 조인 연산의 성능을 향상시킬 수 있다. 조인할 열이 인덱스로 설정되어 있으면 DB가 조인 연산을 빠르게 수행할 수 있따.
6. 범위 검색 최적화: 인덱스를 사용하면 BETWEEN, >, <와 같은 범위 검색 쿼리의 실행 속도를 최적화할 수 있다. 인덱스는 데이터를 정렬된 상태로 유지하기 때문에 범위 검색이 빠르게 처리된다.

- 종합적으로, 인덱스트를 잘 활용하면 DB의 검색, 조회 및 조작 작업의 성능을 향상싴리 수 있으며, DB의 전체적인 성능을 최적화할 수 있다. 하지만 인덱스를 과도하게 생성하거나 잘못된 열에 대해 인덱스를 생성하는 경우, 쓰기 성능이 저하될 수 있으므로 주의가 필요하다.

> 절차 지향 프로그래밍과 객체 지향 프로그래밍의 차이점에 대해 설명해보세요.

1. 절차 지향 프로그래밍:
	- 프로그램을 순차적인 절차나 명령어의 집합으로 간주한다.
	- 코드는 기능별로 분리되고, 각 기능은 함수나 서브루틴으로 표현된다.
	- 데이터와 함수를 분리하고, 함수를 데이터를 조작하는 데 사용된다.
	- 코드의 재사용성이 낮고, 유지보수가 어려울 수 있다.
1. 객체 지향 프로그래밍:
	- 프로그램을 객체의 모음으로 간주한다. 객체는 데이터와 관련된 기능을 함께 묶어서 표현한다.
	- 데이터를 추상화하여 객체의 상태(State)로 표현하고, 함수를 객체의 동작(Method)로 표현한다.
	- 상속, 다형성, 캡슐화와 같은 개념을 사용하여 코드의 재사용성과 유지보수성을 높인다.
	- 객체 간의 상호작용을 통해 복잡한 시스템을 구축할 수 있다.

- 주요한 차이점
	- 구조의 차이:
		  - 절차 지향 프로그래밍: 코드를 기능 단위로 분리하고, 데이터와 함수를 분리하여 생각한다.
		  - 객체 지향 프로그래밍: 코드를 객체 단위로 분리하고, 데이터와 함수를 함께 묶어서 객체로 표현한다.
	  - 재사용성과 확장성:
		  - 절차 지향 프로그래밍: 함수의 재사용성이 낮고, 유지 보수가 어려울 수 있다.
		  - 객체 지향 프로그래밍: 상속, 다형성 등의 개념을 사용하여 코드의 재사용성과 확장성을 높인다.
	  - 코드의 이해와 유지보수성:
		  - 객체 지향 프로그래밍: 현실 세계의 개념과 유사하게 모델링하여 코드를 작성하기 때문에 코드의 이해가 쉽고 유지보수성이 높다.
		  - 절차 지향 프로그래밍: 코드가 단순하고 직관적이지만, 큰 프로젝트에서는 유지보수가 어려울 수 있다.